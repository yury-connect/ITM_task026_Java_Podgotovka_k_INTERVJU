[<<< **PREVIOUS** < _Предыдущая страница_ <<<](/ITM/ITM01_Core1/3_Core1_ProcedureJava.md)

---
## ООП в Java



<details>
        <summary>47. Какие виды классов есть в java?</summary>

**Виды классов в Java**:

1. **Вложенные** классы (_**inner** classes_) – нестатические классы, определённые внутри другого класса. 
Они имеют доступ ко **всем нестатическим** (включая `private`) полям и методам внешнего класса.
2. **Вложенные статические** классы (_static **nested** classes_) – статические классы внутри внешнего класса, 
которые не зависят от экземпляра внешнего класса (имеют доступ так-же к `private static` внешнего...).
3. **Локальные** классы (`local classes`) – классы, объявленные **внутри методов**. 
Они доступны только в рамках метода и могут использовать 
финальные (_или **эффективно финальные**, т.е. которые **не изменяются** после инициализации_) 
переменные метода.
4. **Анонимные** классы – это классы, `созданные на ходу`, **без имени**. 
Обычно используются для реализации `интерфейсов` или `абстрактных классов` 
при необходимости **в одном месте**.
5. **final** классы – классы, которые **не могут быть расширены**.
6. **abstract** классы – классы, которые **не могут быть созданы напрямую**, 
и содержат хотя бы **один** абстрактный метод.
7. **enum** классы – специальные классы, представляющие **набор констант**.

> Кроме перечисленных видов, в Java есть ещё несколько важных категорий классов, которые могут быть полезны:
> 
> 8. **Классы-обёртки** (_Wrapper classes_) – классы для обёртывания примитивных типов данных 
> в объекты (например, _Integer, Double, Character_). 
> 
> 9. Классы с использованием **наследования**:
> > * **Суперклассы** – базовые классы, от которых наследуются другие классы.
> > * **Подклассы** (_или наследники_) – классы, которые расширяют функциональность суперклассов.
> 
> 10. Классы, **использующие интерфейсы** – классы, которые реализуют один или несколько интерфейсов, 
> определяя поведение согласно контракту интерфейса.
> 
> 11. Классы, **использующие абстракции** – абстрактные классы и их реализации, 
> когда необходимо разделить общие характеристики и конкретные реализации.
> 
> 12. Классы с **реализацией паттернов проектирования**:
> > * **Singleton** – класс, который гарантирует наличие только одного экземпляра.
> > * **Factory** – классы, создающие объекты через фабричный метод.
> > * **Proxy** – классы, работающие как прокси-объекты для управления доступом к другим объектам.
> **Классы-сервисы** – обычно используются для реализации бизнес-логики 
> в сервис-ориентированных архитектурах (например, в _Spring_).
> 

```text
***** из методички *****
"1. Вложенные классы – нестатические классы внутри внешнего класса.
2. Вложенные статические классы – статические классы внутри внешнего класса.
3. Локальные классы Java – классы внутри методов. разница между локальным и внутреним
4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно
5. Final, abstract, enum - классы"
```
---
</details>



<details>
        <summary>48. _вложенные классы</summary>

**Расскажите про вложенные классы. В каких случаях они применяются?**

**Вложенные классы** в Java — это классы, определённые внутри других классов. 
Они бывают следующих типов:

1. **Статические вложенные** классы:

* Статический класс **внутри** внешнего класса.
* Может обращаться только к **статическим** членам **внешнего** класса.
* Используется, когда вложенный класс не зависит от экземпляра внешнего класса.

2. **Вложенные** классы (_нестатические_):

* Имеют доступ **к всем полям и методам** внешнего класса.
* Не могут содержать статические объявления, кроме констант.
* Применяются, когда внутренний класс должен работать с экземпляром внешнего класса.

3. **Локальные** классы:

* Определяются внутри методов и видны только в пределах этого метода.
* Не могут быть объявлены как private, public, protected или static.
* Могут обращаться только к эффективно финальным переменным из внешнего метода.

4. **Анонимные** классы:

* Локальные классы без имени.
* Обычно создаются на лету, для реализации интерфейсов или абстрактных классов в одном месте.

**Когда применяются**:
Вложенные классы удобны, когда нужно организовать структуру кода, которая тесно связана 
с внешним классом, либо когда внутренний класс логически должен существовать 
только в контексте внешнего.

```text
***** из методички *****
"Нужны для обслуживания внешних классов

1. Статические вложенные классы (Static nested classes)
        Есть возможность обращения к внутренним статическим полям и методам класса обертки.
2. Вложенные классы
        Есть возможность обращения к внутренним полям и методам класса обертки.
        Не может иметь статических объявлений.
        Внутри такого класса нельзя объявить перечисления.
        Если нужно явно получить this внешнего класса — OuterClass.this
3. Локальный класс
        Видны только в пределах блока, в котором объявлены.
        Не могут быть объявлены как private/public/protected или static 
            (по этой причине интерфейсы нельзя объявить локально).
        Не могут иметь внутри себя статических объявлений (полей, методов, классов), 
            но могут иметь константы (static final)
        Имеют доступ к полям и методам обрамляющего класса.
        Можно обращаться к локальным переменным и параметрам метода, 
            если они объявлены с модификатором final или являются effectively final.
4. Анонимные классы
        Локальный класс без имени."
```
---
</details>



<details>
        <summary>49. Что такое «локальный класс»? Каковы его особенности?</summary>

**Локальный класс** – это класс, объявленный **внутри метода**, **конструктора** или **блока инициализации**.

**Особенности**:
* Обладает всеми свойствами **нестатического вложенного класса**.
* **Создавать экземпляры** такого класса можно **только внутри метода**, в котором он объявлен.
* Может использовать **только** `final` или `эффективно final` переменные метода.
* **Нельзя** объявлять с модификаторами доступа (`public`, `private`, `protected`).
* Имеет **доступ ко всем членам внешнего** класса.
* Может быть создан **внутри блоков инициализации** (`static` и `нестатических`).

```text
***** из методички *****
"Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического 
вложенного класса, только создавать их экземпляры можно только в методе.

Особенности:
Локальные классы способны работать только с final переменными метода. 
С 8+ версий Java можно использовать не final переменные в локальных классах, 
но только при условии, что они не будут изменяться.
Локальные классы нельзя объявлять с модификаторами доступа (`public`, `private`, `protected`).
Локальные классы обладают доступом к переменным метода.
Может быть создан внутри блоков инициализации."
```
---
</details>



<details>
        <summary>50. Что такое «анонимные классы»? Где они применяются?</summary>

Анонимный класс — это **вложенный локальный класс без имени**, который объявляется и создаётся 
одновременно в месте его использования.

**Особенности**:
* Не имеет имени, поэтому его нельзя переиспользовать.
* Создаётся на лету в любом месте, где разрешены выражения.
* Может быть статическим или нестатическим в зависимости от контекста.
* Ограничен:
> * Используется только в месте создания.
> * Не может объявлять новых методов, кроме тех, что переопределяет.
> * Всегда final (нельзя унаследовать).
> * Видим только внутри метода, где объявлен.
>  

**Где применяется**:
* Для **реализации интерфейсов** (например, `Comparator`).
* Для создания **объектов процессов** (`Thread`, `Runnable`).
* В **статических фабричных методах**.
* Для **инициализации** `final` **статических полей** в сложных перечислениях (`enum`).

**Вывод**:
Анонимные классы удобны для **разового использования** при создании объектов 
с переопределённым поведением без необходимости отдельного именованного класса.

```text
***** из методички *****
"Это вложенный локальный класс без имени, который разрешено декларировать в любом месте 
обрамляющего класса, разрешающем размещение выражений. 
Создание экземпляра анонимного класса происходит одновременно с его объявлением. 
В зависимости от местоположения анонимный класс ведет себя как статический 
либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:
Их использование разрешено только в одном месте программы - месте его создания;
Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, 
так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:
* создания объекта функции (function object), например реализация интерфейса Comparator;
* создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
* в статическом методе генерации;
* инициализации открытого статического поля final, которое соответствует сложному перечислению типов, 
    когда для каждого экземпляра в перечислении требуется отдельный подкласс.

Анонимные классы всегда являются конечными классами. 
Каждое объявление анонимного класса уникально. Видны только внутри того метода, в котором определены. 
В документации Oracle приведена хорошая рекомендация: 
«Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». "
```
---
</details>



<details>
        <summary>51 _доступ к полю внешнего класса?</summary>

**Каким образом из вложенного класса получить доступ к полю внешнего класса?**

**Доступ к полю внешнего класса из вложенного класса**

1. **Статический** вложенный класс (static **nested** class)

> * Имеет доступ только к `static` полям и методам внешнего класса.
> * Для доступа к нестатическим полям нужно создать экземпляр внешнего класса.

2. **Нестатический** вложенный класс (**inner** class)

> * Имеет прямой доступ ко всем полям (включая `private`) внешнего класса.

3. Если **имя поля совпадает** с полем вложенного класса:

> * Используется `OuterClass.this.field` для **явного** указания, что поле принадлежит внешнему классу.

```text
***** из методички *****
"Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.
Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую. 

В случае, если у вложенного класса уже существует поле с таким же литералом, 
то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field."
```
---
</details>



<details>
        <summary>52. Что такое перечисления (enum)?</summary>

**Перечисление** (enum) — это тип данных, представляющий **набор логически связанных констант**.

**Особенности**:
* Фактически является **классом**, поэтому можно определять 
`переменные`, `конструкторы`, `методы` и `поля`.
* Конструктор всегда `private` (_неявно_), **нельзя** создавать экземпляры извне.
* Каждая константа `enum` — это **экземпляр** самого `enum`-класса.
* Можно определять **методы** для отдельных констант.

**Методы** `enum`:
* `ordinal()` — возвращает **порядковый номер** константы (нумерация с **0**).
* `values()` — возвращает **массив всех констант**.

**Преимущества** перед `static final int`:
* **Типобезопасность** — невозможно присвоить `enum` значение другого типа.
* **Удобство** — `enum` поддерживает методы и позволяет организовать логику внутри себя.

**Ограничения**:
* **Нельзя использовать** операторы сравнения (`>`, `<`, `>=`, `<=`).
* Требует **больше памяти**, чем `static final int`.

**Применение**:
Используются, когда нужно **ограничить набор допустимых значений** 
(например, `дни недели`, `времена года`, `статусы заказа`).

```text
***** из методички *****
"Перечисления представляют набор логически связанных констант. 

Перечисление фактически представляет новый класс, поэтому мы можем определить 
переменную данного типа и использовать ее.

Перечисления, как и обычные классы, могут определять конструкторы, поля и методы. 
Следует отметить, что конструктор по умолчанию приватный. 
Также можно определять методы для отдельных констант.

Методы:
-ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0)
-values() возвращает массив всех констант перечисления

Еnum имеет ряд преимуществ при использовании в сравнении с static final int. 
Главным отличием является то что используя enum вы можете проверить тип данных.

Недостатки
- К ним не применимы операторы >, <, >=, <=
- enum также требует больше памяти для хранения чем обычная константа.

Нужны для ограничения области допустимых значений: например, времена года, дни недели"
```
---
</details>



<details>
        <summary>53. Как проблема ромбовидного наследования решена в java?</summary>

В Java **нет множественного наследования классов**, что предотвращает проблему ромбовидного наследования.

**Почему множественное наследование классов не поддерживается?**

Если класс `C` наследует два класса `A` и `B`, а они оба унаследованы от `SuperClass`, 
возникает конфликт: компилятор не знает, чей метод `SuperClass` вызывать.

**Как решено в Java?**
1. **Классы побеждают**: Если метод определён в классе или его суперклассе, 
он **приоритетнее**, чем метод из интерфейса.

2. **Саб-интерфейсы важнее**: Если интерфейс `B` наследует `A` и у обоих есть методы 
   с одинаковой сигнатурой, используется метод из `B`.

3. Явный выбор: Если класс наследует два интерфейса с одинаковыми `default`-методами, 
нужно явно указать, какой метод использовать через `Interface.super.method()`, 
иначе возникнет **ошибка компиляции**.

Таким образом, Java **избегает** неявной двусмысленности и требует 
от разработчика явного разрешения конфликтов при необходимости.

```text
***** из методички *****
"В Java нет поддержки множественного наследования классов.

Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, 
а классы ClassA и ClassB — обычные классы наследники SuperClass, 
а класс ClassC наследуется от ClassA и ClassB одновременно. 
Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, 
метод какого именно суперкласса должен быть вызван. 
Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.

1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший 
приоритет перед дефолтными методами интерфейсов.

2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). 
Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.

3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, 
должен явно через super определить, какой именно метод вызвать, 
иначе компилятор будет сильно материться."
```
---
</details>



<details>
        <summary>54. Что такое конструктор по умолчанию?</summary>

**Конструктор по умолчанию** — это конструктор **без аргументов**, который **автоматически** создаётся 
компилятором, если в классе **не объявлено других** конструкторов.

**Особенности**:
* Генерируется только **если нет других** конструкторов.
* **Не принимает аргументов** и **не содержит логики**, кроме вызова конструктора родителя (`super()`).
* Если в классе уже **есть хотя бы один** конструктор, по умолчанию **не создаётся**, 
и его нужно объявлять явно, если он необходим.

```text
***** из методички *****
"Если у какого-либо класса не определить конструктор, 
то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».

Если у класса уже определен какой-либо конструктор, 
то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно."
```
---
</details>



<details>
        <summary>55. Могут ли быть приватные конструкторы? Для чего они нужны?</summary>

**Да**, конструкторы могут быть `private`. 

Это **запрещает создание объектов класса извне**, за исключением методов самого класса.

**Применение**:
* **Singleton** — ограничение создания экземпляров до одного.
* **Фабричные методы** — создание объектов через статические методы (`Factory Method`).
* **Утилитарные классы** (`Utility classes`, например `Math`, `Collections`) — запрещение создания экземпляров.
* **Enum** — все перечисления (`enum`) имеют **приватный конструктор** по умолчанию.

```text
***** из методички *****
"Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
Нужен для реализации паттернов, например singleton."
```
---
</details>



<details>
        <summary>##### 56. _классы-загрузчики и _динамическая загрузка классов.</summary>

**Расскажите про классы-загрузчики и про динамическую загрузку классов.**

**Классы-загрузчики** (_ClassLoaders_) и **динамическая загрузка классов** в Java

JVM использует **три** основных загрузчика классов:

1. **Boostrap ClassLoader** (_базовый/ корневой _)
> * Загружает основные классы начальной загрузки (`java.lang.*`, `java.util.*`) 
> из `rt.jar` и др, присутствующих в каталоге `$JAVA_HOME/jre/lib`
2. **Extension ClassLoader** (_расширений_)
> * Подкласс `Boostrap ClassLoader` и суперкласс загрузчика классов **приложений**.
> Загружает расширения стандартных библиотек Java, 
> присутствующие в каталоге `$JAVA_HOME/jre/lib/ext/`.
3. **AppClassLoader** (_системный_)
> * Конечный загрузчик **классов** и подкласс загрузчика `Extension ClassLoader`
> * Загружает классы приложения, указанные в `CLASSPATH`.
> * По умолчанию путь к классу устанавливается как текущий каталог приложения, 
> но его можно изменить, добавив параметр 
> командной строки `-classpath` или `-cp`

**Динамическая загрузка классов**

Происходит **во время выполнения** с помощью:

* `Class.forName("имя.класса")` — загружает и инициализирует класс.
* `ClassLoader.loadClass("имя.класса")` — загружает, но не инициализирует.

**Зачем нужна динамическая загрузка?**
* **Плагины и расширения** (_загрузка неизвестных классов во время работы_).
* **Рефлексия** (динамическое _создание объектов и вызов методов_).
* **Фреймворки и контейнеры** (_`Spring`, `Hibernate` и др._).

###### Архитектура JVM
[![Блок-схема: три встроенных загрузчика классов](/ITM/ITM01_Core1/imgs/2025-03-05_10-43-42.png)](https://nuancesprog.ru/p/15245/)
[**ссылка на источник**](https://nuancesprog.ru/p/15245/)
[![Описание: три встроенных загрузчика классов](/ITM/ITM01_Core1/imgs/2025-03-05_11-24-03.png)](https://nuancesprog.ru/p/15245/)

```text
***** из методички *****
При запуске JVM, используются три загрузчика классов:

- Bootstrap ClassLoader - главный загрузчик
- загружает платформенные классы JDK из архива rt.jar

- AppClassLoader - системный загрузчик
- загружает классы приложения, определенные в CLASSPATH 

- Extension ClassLoader - загрузчик расширений 
- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.

Динамическая загрузка происходит ""на лету"" в ходе выполнения программы 
с помощью статического метода класса Class.forName(имя класса). 
Для чего нужна динамическая загрузка? Например мы не знаем какой класс 
нам понадобится и принимаем решение в ходе выполнения программы 
передавая имя класса в статический метод forName().
```
---
</details>



<details>
        <summary>57. _конструкторы...</summary>

**Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?**

1. Конструктор **по умолчанию**
> * Не принимает аргументы.
> * Генерируется компилятором, если не объявлен явно.
> * Инициализирует поля значениями по умолчанию.

2. Конструктор **копирования**
> * Принимает объект того же класса.
> * Создает новый объект с тем же состоянием, копируя значения полей.
> * В Java отсутствует встроенный механизм копирующего конструктора, его нужно реализовывать вручную.

3. Конструктор **с параметрами**
> * Принимает аргументы, обычно для инициализации полей.
> * Позволяет создавать объекты с заданными значениями сразу при инициализации.

```text
***** из методички *****
"-У конструктора по умолчанию отсутствуют какие-либо аргументы. 
-Конструктор копирования принимает в качестве аргумента уже существующий 
объект класса для последующего создания его клона.
-Конструктор с параметрами имеет в своей сигнатуре аргументы 
(обычно необходимые для инициализации полей класса)."
```
---
</details>



<details>
        <summary>58. _модификаторы модификаторы и классы?</summary>

**Какие модификаторы доступа есть в Java? Какие применимы к классам?**

* `private` – доступ только внутри самого класса.
* `default` (_package-private_) – доступен внутри **того же пакета**.
* `protected` – доступен внутри того же **пакета** + в **наследниках вне пакета**.
* `public` – доступен отовсюду.

**Применимость к классам**
* `public` – класс доступен во всех пакетах.
* '`default`' – доступен только внутри своего пакета.
* `private` и `protected` – **не применяются** к верхнеуровневым 
(_top-level_) классам (_ниже -**развернуто**_).

![`private` и `protected` _ к верхнеуровневым классам](/ITM/ITM01_Core1/imgs/2025-03-05_10-21-26.png)

```text
***** из методички *****
Private – доступ к компоненту только из этого класса, 
    в котором объявлен.
Default – Переменная или метод будут доступны 
    для любого другого класса в том же пакете.
Protected – Поля protected доступны всем классам 
    внутри пакета, а также всем классам-наследникам вне пакета.
Public – доступ к компоненту из экземпляра 
    любого класса и любого пакета.

Класс может быть объявлен с модификатором public и default.
```
---
</details>



<details>
        <summary>59. Что означает модификатор static?</summary>

Модификатор **static** в Java
* **Статическая переменная** принадлежит **классу**, а **не** конкретному объекту.
* **Статический метод** может работать **только** с `static` полями и методами класса.
* **Статический вложенный класс** не имеет доступа к нестатическим членам внешнего класса.
* **Статический блок** (`static { ... }`) выполняется **один раз** _при **загрузке** класса_.

```text
***** из методички *****
Статическая переменная - это переменная, 
    ринадлежащая классу, а не объекту. 
    
А статический класс- это вложенный класс, 
    который может обращаться только 
    к статическим полям 
    обертывающего его класса.
     
Внутри static метода нельзя вызвать 
    не статический метод по имени класса.
```
---
</details>



<details>
        <summary>60. Может ли статический метод быть переопределён или перегружен?</summary>

* **Переопределить** (_override_) **нельзя**. Если в подклассе объявить статический метод 
с такой же сигнатурой, он **скроет** (_hide_) метод родительского класса, но **не заменит** его.
* **Перегрузить** (_overload_) **можно**. Можно создать несколько статических методов с одинаковым именем, 
но разными параметрами (по количеству или типу).

```text
***** из методички *****
"Нельзя переопределять статические методы. 
Если вы объявите такой же метод в классе-наследнике (subclass), 
т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. 
Это явление известно как сокрытие методов (hiding methods). 

Перегружен - да. 
Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, 
если количество их параметров или типов различается."
```
---
</details>



<details>
        <summary>61. Могут ли нестатические методы перегрузить статические?</summary>

**Да**, нестатические методы **могут** перегрузить статические.

Это будет обычная **перегрузка** (_overloading_), а не переопределение. В таком случае:

* Статический метод будет вызываться через **имя класса** (`ClassName.method()`),
* Нестатический — через **экземпляр класса** (`instance.method()`).

Такой код компилируется без ошибок, так как это просто два метода с **разными** сигнатурами.

```text
***** из методички *****
Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.
```
---
</details>



<details>
        <summary>62. _сузить уровень доступа/тип возвр. знач-я при переопределении?</summary>

**Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?**

**Да**, при переопределении метода в Java:

1. **Нельзя сузить** модификатор доступа, но **можно его расширить**:

* ✅ `protected` → `public` (**разрешено**)
* ❌ `public` → `protected` (**нельзя**)
* ❌ `protected` → `private` (**нельзя**)

**Можно сузить тип возвращаемого значения** (если они ковариантны):

* Если оригинальный метод возвращает A, то переопределённый метод может возвращать B, если B extends A.
* Например:
```java
 class Parent {
    Number getValue() { return 42; }
 }

class Child extends Parent {
    Integer getValue() { return 42; } // Разрешено, Integer – подкласс Number
}

```
* ❌ **Существенное изменение типа недопустимо** (например, `String` вместо `Number`).

```text
***** из методички *****
"При переопределении метода нельзя сузить модификатор доступа к методу 
(например, с public до private), но можно расширить.

Изменить тип возвращаемого значения нельзя, 
но можно сузить возвращаемое значение, если они совместимы. 
Например, если метод возвращает объект класса, а
 переопределенный метод возвращает класс-наследник."
```
---
</details>



<details>
        <summary>63. _изменения в сигнатуре при переопределении / модификатора?</summary>

**Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?**

**Да**, при **переопределении** метода в Java:

1. Сигнатура (`имя` + `параметры`) остаётся **неизменной**
* Нельзя менять **имя** метода.
* Нельзя менять **количество** или **тип** параметров (это уже **перегрузка**, а не **переопределение**).

2. Можно **расширить** уровень доступа, но **не сузить**
* ✅ protected → public (разрешено)
* ❌ public → protected (нельзя)

3. Можно **сузить возвращаемый тип** (_ковариантность_)
* ✅ Если метод в родительском классе возвращает `Animal`, 
то в подклассе можно возвращать `Dog`, если `Dog extends Animal`.
* ❌ Нельзя заменить на другой несвязанный тип (`String` вместо `Animal`).

4. Можно изменять секцию `throws` (_но **с ограничениями**_)
* Можно **не указывать** `throws`, даже если родительский метод его объявляет.
* Можно добавить **только подкласс** исключения, объявленного в `throws` родительского метода.
* Можно добавить `RuntimeException` (_потому что это непроверяемое исключение_).
* ❌ Нельзя добавить новое проверяемое исключение, которого нет в throws родительского метода.

```text
***** из методички *****
"В сигнатуре(имя + параметры) менять ничего нельзя.

Возможно расширение уровня доступа.

Изменять тип возвращаемого значения при переопределении метода разрешено 
только в сторону сужения типа (вместо родительского класса - наследника).

Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, 
если уже определена у метода родительского класса. 
Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных 
или исключения RuntimeException. 
Порядок следования таких элементов при переопределении значения не имеет."
```
---
</details>



<details>
        <summary>64. Могут ли классы быть статическими?</summary>

В Java **классы верхнего уровня** (_top-level classes_) **не могут быть статическими**.

Однако **вложенные** (_nested_) классы **могут** быть объявлены **static**. 
Такие классы называются **статическими вложенными классами** (**_static nested class_**).

**Особенности `static` класса:**
* ✅ Может обращаться только к static полям и методам внешнего класса.
* ✅ Не имеет неявной ссылки на экземпляр внешнего класса.
* ✅ Создаётся без создания экземпляра внешнего класса.

```java
class Outer {
    static String staticField = "Static field";

    static class StaticNested {
        void display() {
            System.out.println("Accessing: " + staticField); // Разрешено
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer.StaticNested nested = new Outer.StaticNested();
        nested.display();
    }
}
```

* ⛔ **Верхнеуровневые** классы (`public`, `default`) **не могут быть** `static`:

```java
static class MyClass {  // ❌ Ошибка: нельзя сделать верхний уровень статическим
}
```

```text
***** из методички *****
"Класс можно объявить статическим за исключением классов верхнего уровня.
Такие классы известны как «вложенные статические классы» (nested static class). "
```
---
</details>



<details>
        <summary>65. Что означает модификатор final? К чему он может быть применим?</summary>

`final` ограничивает возможность изменения.

* **Класс**: запрещает наследование.
* **Метод**: запрещает переопределение.
* **Переменная (примитив)**: значение неизменно.
* **Переменная (ссылка)**: нельзя переназначить ссылку, но сам объект можно изменять.
* **Массив**: нельзя сменить ссылку, но можно менять элементы.

`final` и `abstract` **несовместимы**.

```text
***** из методички *****
Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. 
Следует также отметить, что к abstract-классам нельзя применить модификатор final, 
т.к. это взаимоисключающие понятия.

Для переменных примитивного типа это означает, что однажды присвоенное значение 
не может быть изменено

Для ссылочных переменных это означает, что после присвоения объекта, 
нельзя изменить ссылку на данный объект. 
Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.

Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, 
уже нельзя ее изменить, но можно изменять состояние объекта.
```
---
</details>



<details>
        <summary>66. Что такое абстрактные классы? Чем они отличаются от обычных?</summary>

**Абстрактный** класс — это класс, от которого **нельзя создать объект**.

* Может содержать **абстрактные** (_без реализации_) и обычные методы.
* Используется как **основа** для наследников, обязывая их реализовать абстрактные методы.
* Может иметь **конструкторы**, **поля** и **методы с реализацией**.
* Может **наследоваться от другого абстрактного** класса.

> **Улучшения** `Абстрактного класса` с развитием java: 
> * **Java 8**: возможность добавлять `default` и `static` методы **в интерфейсы**, 
> что сократило необходимость использовать абстрактные классы.
> * **Java 9**: появились `private` методы в интерфейсах, 
> что ещё больше уменьшило необходимость в абстрактных классах.
> * **Java 14**: добавлены `sealed` классы, ограничивающие наследование, 
> что дало дополнительную гибкость в проектировании классов.

```text
***** из методички *****
"Абстрактным называется класс, на основе которого не могут создаваться объекты.
Как обычный класс, но с абстрактными методами. 
Нельзя создать объект или экземпляр абстрактного класса.

Наследниками абстрактного класса могут быть другие абстрактные классы"
```
---
</details>



<details>
        <summary>67. Может ли быть абстрактный класс без абстрактных методов?</summary>

```text
***** из методички *****
Класс может быть абстрактным без единого абстрактного метода, 
если у него указан модификатор abstract.
```
---
</details>



<details>
        <summary>68. _конструкторы у абстрактных классов</summary>

**Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?**

**Да**, абстрактные классы **могут иметь конструкторы**. 

Они нужны для инициализации полей и логики, общей для всех наследников. 

Конструкторы абстрактного класса вызываются при создании объекта подкласса, 
обеспечивая корректную настройку его состояния.

```text
***** из методички *****
"Да. Необходимы для наследников.

В абстрактном классе в Java можно объявить и определить конструкторы. 
Даже если вы не объявили никакого конструктора, компилятор добавит 
в абстрактный класс конструктор по умолчанию без аргументов. 
Абстрактные конструкторы будут часто использоваться для обеспечения 
ограничений класса или инвариантов, таких как минимальные поля, 
необходимые для настройки класса."
```
---
</details>



<details>
        <summary>69. _Интерфейсы и их модификаторы</summary>

**Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?**

**Интерфейс** — это контракт, определяющий поведение классов, которые его реализуют. 
Он содержит `абстрактные методы` и `статические константы`.

**По умолчанию**:

* **Методы** — `public` и `abstract`.
* **Поля** — `public static final`.

```text
***** из методички *****
Интерфейс описывает поведение, которым должны обладать классы, реализующие этот интерфейс. 
«Поведение» — это совокупность методов. Интерфейс — это план класса или, можно сказать, 
набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, 
но не содержит конструктора. 
Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. 
Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой. 

- методы интерфейса являются публичными (public) и абстрактными (abstract), 
- поля — public static final. 
```
---
</details>



<details>
        <summary>70. _Интерфейсы и абстрактные классы</summary>

**Чем интерфейсы отличаются от абстрактных классов? 
В каких случаях следует использовать абстрактный класс, а в каких интерфейс?**

**Различия**:

* **Интерфейсы** определяют только поведение (методы), без состояний (кроме public static final полей). 
Абстрактные классы могут иметь как `методы`, так и `состояние` (_обычные поля_).
* Класс может **наследовать** только **один абстрактный класс**, но реализовать **несколько интерфейсов**.
* **Абстрактный класс используется**, когда есть отношение "**is-a**", 
а интерфейсы подходят для общей функциональности, не связанной с иерархией.
* **Абстрактный класс** может содержать реализованные методы, интерфейс поддерживает default-методы (_с Java 8_).

**Когда что использовать**:

* **Абстрактный класс** — если нужен общий код и состояние для родственных классов.
* **Интерфейс** — если требуется общее поведение для несвязанных классов.

```text
***** из методички *****
1.        Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) 
            у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.
2.        Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. 
            Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
3.        Абстрактные классы используются, когда есть отношение ""is-a"", то есть класс-наследник 
            прасширяет базовый абстрактный класс, а интерфейсы могут быть реализованы 
            разными классами, вовсе не связанными друг с другом.
4.        Абстрактный класс может реализовывать методы; интерфейс может реализовывать 
            дефолтные методы начиная с 8й версии.

https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java (Q5)
```
[ссылка](https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java")
---
</details>



<details>
        <summary>71. Может ли один интерфейс наследоваться от другого? От двух других?</summary>

**Да**, интерфейс может наследоваться от одного или нескольких других интерфейсов с помощью `extends`. 

При этом он наследует **все** методы родительских интерфейсов.

```text
***** из методички *****
Да, может. Используется ключевое слово extends
```
---
</details>



<details>
        <summary>72. Что такое дефолтные методы интерфейсов? Для чего они нужны?</summary>

**Дефолтные методы** (`default`) появились в **Java 8** и позволяют интерфейсам содержать реализацию методов. 

Они нужны для обратной совместимости, чтобы при добавлении новых методов в интерфейс 
существующие классы не были обязаны их реализовывать.

```text
***** из методички *****
"В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором default. 
И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, 
реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости. 

(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены 
их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.)
```
---
</details>



<details>
        <summary>73. _Ромбовидное наследование / интерфейсы</summary>

**Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии `default` методов?**

Если класс реализует **несколько** интерфейсов с одинаковыми `default`-методами, 
он **должен явно указать, какой метод использовать**, вызвав его через `InterfaceName.super.method()`. 

Если этого не сделать, компилятор выдаст ошибку.

```text
***** из методички *****
"класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать:
InterfaceB.super.method();"
```
---
</details>



<details>
        <summary>74. _Порядок вызова конструкторов и блоков инициализации_</summary>

**Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?**

1. `Статические блоки инициализации` вызываются в порядке **наследования** — от родителя к наследнику 
(_один раз при загрузке класса_).
2. `Нестатические` (_инициализирующие_) блоки и `конструкторы` вызываются **попарно**: 
сначала **блок инициализации**, затем **конструктор** — тоже **от родителя к наследнику**.

```text
***** из методички *****
1. Статические блоки от первого до последнего предка(от предка до наследника)
2. Попарно динамической блок инициализации и конструктор от первого до последнего предка
```
---
</details>



<details>
        <summary>75. Зачем нужны и какие бывают блоки инициализации?</summary>

Блоки инициализации используются для задания начального состояния объекта или класса.

Виды:

* 🔹 **Статические** (`static {}`) — выполняются **один раз при загрузке класса**, 
используются **для инициализации статических переменных**.
* 🔹 **Нестатические** (`{}`) — выполняются **при каждом создании объекта**, 
используются **для инициализации нестатических полей перед вызовом конструктора**.

```text
***** из методички *****
Инициализация - это когда мы впервые задаем переменной какое-либо значение.
Существуют статические и нестатические блоки инициализации.
```
---
</details>



<details>
        <summary>76. Для чего в Java используются статические блоки инициализации?</summary>

Статические блоки инициализации (`static {}`) выполняются **один раз при загрузке класса**. 
Используются для **инициализации статических переменных** 
и выполнения кода, который должен сработать **до создания объектов**.

```text
***** из методички *****
Статические блоки инициализация используются для выполнения кода, 
который должен выполняться один раз при инициализации класса загрузчиком классов, 
в момент предшествующий созданию объектов этого класса при помощи конструктора. 
Такой блок принадлежит только самому классу.
```
---
</details>



<details>
        <summary>77. _исключительная ситуация в блоке инициализации_</summary>

**Что произойдет, если в блоке инициализации возникнет исключительная ситуация?**

* Если в **нестатическом** блоке инициализации возникает исключение, 
оно должно быть объявлено в `throws` всех конструкторов, иначе ошибка компиляции. 

* В **статическом** блоке проверяемые исключения (_**checked** exceptions_) запрещены — 
их выбрасывание вызовет **ошибку компиляции**.

```text
***** из методички *****
"Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, 
требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. 
Иначе будет ошибка компиляции. 

Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции."
```
---
</details>



<details>
        <summary>78. _ошибки в блоке инициализации класса_</summary>

**Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?**

При ошибке в блоке инициализации:

* 🔹 **Статический блок** → выбрасывает `ExceptionInInitializerError` 
(_если исключение — наследник_ `RuntimeException`), либо `Error` (_если исключение — его наследник_).
* 🔹 **Нестатический блок** → пробрасывает исходное исключение (RuntimeException), либо Error.
* 🔹 `ThreadDeath` → исключение **не выбрасывается**.

```text
***** из методички *****
Если возникшее исключение - наследник RuntimeException:
-для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;
-для нестатических будет проброшено исключение-источник.

Если возникшее исключение - наследник Error, 
то в обоих случаях будет выброшено java.lang.Error.

Если исключение: java.lang.ThreadDeath - смерть потока. 
В этом случае никакое исключение выброшено не будет."
```
---
</details>



<details>
        <summary>79. Что такое класс Object?</summary>

`Object` — базовый класс для всех объектов в Java. 
Все классы неявно наследуют его и получают доступ к его методам. 
Это позволяет использовать переменные типа `Object` для хранения объектов любых классов.

Также `Object` играет **ключевую** роль в механизмах `рефлексии` и `полиморфизма`.

```text
***** из методички *****
"Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, 
соответственно, наследуют его методы

Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. 
В результате объект Object может ссылаться на объект любого другого класса.

Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных 
о программе во время её выполнения."
```
---
</details>



<details>
        <summary>80. _Методы есть у класса Object_</summary>

**Какие методы есть у класса `Object` (`перечислить все`)? Что они делают?**

**Методы класса** `Object`:

**Общие**:
* 🔹 `equals(Object obj)` — проверяет равенство объектов.
* 🔹 `hashCode()` — возвращает хеш-код объекта.
* 🔹 `toString()` — строковое представление объекта.
* 🔹 `getClass()` — возвращает объект Class, представляющий тип данного объекта.
* 🔹 `clone()` — создает копию объекта (если Cloneable).
* 🔹 `finalize()` (deprecated) — вызывается перед удалением объекта GC (не гарантируется вызов).

Для **многопоточности**:
* 🔹 `wait()` — переводит поток в ожидание, освобождая монитор.
* 🔹 `wait(long timeout)` — ожидание с максимальным временем в миллисекундах.
* 🔹 `wait(long timeout, int nanos)` — ожидание с точностью до наносекунд.
* 🔹 `notify()` — пробуждает один поток, ожидающий монитор объекта.
* 🔹 `notifyAll()` — пробуждает все потоки, ожидающие монитор.

```text
***** из методички *****
- equals() - проверка на равенство двух обьектов
- hashCode() - изначально случайно число int
- toString() - представления данного объекта в виде строки.
- getClass() - получение типа данного обьекта
- clone() -  клонирует объект методом.
- finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)

для многопоточки

- notify() - «размораживает» одну случайную нить
- notifyAll() - «размораживает» все нити данного монитора
- wait() - нить освобождает монитор и «становится на паузу»
- wait(long timeOut) - нить освобождает монитор и «становится на паузу», 
принимает максимальное время ожидания в миллисекундах.
- wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу», 
принимает максимальное время ожидания в миллисекундах, дополнительное время, 
в диапазоне наносекунд 0-999999."
```
---
</details>



<details>
        <summary>81. Расскажите про equals и hashcode</summary>

`equals()` и `hashCode()`:
* `equals()` — метод сравнения объектов, проверяющий их состояние (_значения полей_), а не ссылки.
* `hashCode()` — метод, возвращающий целочисленный хеш-код объекта, 
используемый в структурах данных, таких как `HashMap`, `HashSet`.

**Свойства** `equals()`:
1. **Рефлексивность** — `x.equals(x)` всегда `true`.
2. **Симметричность** — `a.equals(b)` ⇔ `b.equals(a)`.
3. **Транзитивность** — если `a.equals(b)` и `b.equals(c)`, то `a.equals(c)`.
4. **Согласованность** — повторные вызовы возвращают одинаковый результат, если объект не изменился.
5. **Связь** с `hashCode()` — равные объекты (`equals() == true`) должны иметь одинаковый `hashCode()`.

При переопределении `equals()` обязательно переопределять `hashCode()`, 
чтобы объект корректно работал в хеш-коллекциях.

```text
***** из методички *****
Хеш-код — это целочисленный результат работы метода, которому 
в качестве входного параметра передан объект.
Если более точно, то это битовая строка фиксированной длины, 
полученная из массива произвольной длины. 

Equals - это метод, определенный в Object, который служит для сравнения объектов. 
При сравнении объектов при помощи == идет сравнение по ссылкам. 
При сравнении по equals() идет сравнение по состояниям объектов. 

Свойства equals():
•        Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)
•        Рефлексивность: для любого заданного значения x, выражение x.equals(x) 
                                         должно возвращать true.
                                         Заданного — имеется в виду такого, что x != null
•        Постоянство: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, 
пока какое-либо значение свойств объекта не будет изменено.
•        Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)
•        Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же 
значение hashCode()


При переопределении equals() обязательно нужно переопределить метод hashCode(). 
Равные объекты должны возвращать одинаковые хэш коды.
```
---
</details>



<details>
        <summary>82. Реализация hashCode() и equals() в классе Object</summary>

**Каким образом реализованы методы `hashCode()` и `equals()` в классе `Object`?**

Реализация `equals()` и `hashCode()` в классе `Object`
1. Реализация `equals()` в `Object`
   Метод сравнивает **ссылки** на объекты. Если ссылки указывают на один и тот же объект, 
возвращает `true`, иначе — `false`. 
Для логического сравнения содержимого объектов метод необходимо переопределять.

2. Реализация `hashCode()` в `Object`
   Метод возвращает `числовой идентификатор`, который остается неизменным для одного 
и того же объекта в течение его жизни. Реализован на нативном уровне 
и может использовать разные алгоритмы в зависимости от _JVM_, включая случайную генерацию, 
адрес объекта в памяти или комбинацию битовых операций.

**Коллизи:**

**Коллизия** — это ситуация, когда разные объекты имеют одинаковый `hashCode()`. 
При переопределении метода важно выбирать алгоритм, минимизирующий вероятность коллизий, 
особенно для использования в структурах данных, зависящих от хеширования.

```text
***** из методички *****
"1 - Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:

public boolean equals(Object obj) {
  return (this == obj);
}

2 - HashCode реализован таким образом, что для одного и того же входного объекта, 
хеш-код всегда будет одинаковым.
Реализация метода Object.hashCode() описана как native, т.е. написана не на Java. 
Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, 
объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов 
на базе значения переменной hashCode.

0. Случайно сгенерированное число.
1. Функция адреса объекта в памяти.
2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).
3. Последовательность.
4. Адрес объекта в памяти, приведённый к целочисленному значению.
5. Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)

public native int hashCode();

Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. 
Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода."
```
---
</details>



<details>
        <summary>83. Зачем нужен equals(). Чем он отличается от операции ==?</summary>

Метод `equals()` предназначен для **логического** (_содержательного_) сравнения объектов. 
Его переопределяют, если требуется сравнивать объекты по их **внутренним данным**, а **не по месту в памяти**.

**Разница между** `equals()` **и** `==`
* `==` сравнивает ссылки на объекты, т.е. проверяет, указывают ли они на один и тот же участок памяти.
* `equals()` сравнивает содержимое объектов (_если метод переопределен, иначе работает так же, как_ `==`).

```text
***** из методички *****
equals() -  сравнение по состоянию, == -  по ссылкам
```
---
</details>



<details>
        <summary>84. Правила переопределения equals()</summary>

1. **Рефлексивность** – объект всегда равен самому себе.
2. **Симметричность** – если `a.equals(b)` == `true`, то` b.equals(a)` == `true`.
3. **Транзитивность** – если `a.equals(b)` == `true` и `b.equals(c)` == `true`, то `a.equals(c)` == `true`.
4. **Согласованность** – повторные вызовы `equals()` должны давать одинаковый результат, если объект не изменялся.
5. **Сравнение с** `null` – любой объект должен возвращать `false`, если сравнивается с `null`.

Также важно:

* Проверять, является ли переданный объект тем же самым (`this == o`).
* Убедиться, что он принадлежит тому же классу (`getClass() != o.getClass()`).
* Сравнивать значимые поля объекта.

```text
***** из методички *****
"
-Рефлексивность: Объект должен равняться себе самому.
-Симметричность: если a.equals(b) возвращает true, то b.equals(a) должен тоже вернуть true.
-Транзитивность: если a.equals(b) возвращает true и b.equals(c) тоже возвращает true, 
то c.equals(a) тоже должен возвращать true.
-Согласованность: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, 
пока какое-либо значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, 
то они будут равны пока их свойства остаются неизменными.
-Неравенство с  null: объект должны быть проверен на null. Если объект равен null, 
то метод должен вернуть false, а не NullPointerException. Например, a.equals(null) должен вернуть false.

@Override
public boolean equals(Object o) {
   if (this == o) return true;
   if (o == null || getClass() != o.getClass()) return false;
   Man man = (Man) o;
   return dnaCode == man.dnaCode;
"
```
---
</details>



<details>
        <summary>85. _переопределить equals() и не переопределить hashcode()_</summary>

**Что будет если переопределить `equals()` и не переопределить `hashcode()`**

Если переопределить `equals()`, но не переопределить `hashCode()`, **нарушится контракт** 
между этими методами. Это приведёт к некорректной работе коллекций, использующих хеширование, 
таких как `HashMap`, `HashSet` и `HashTable`.

Основные последствия:

* Объекты, которые считаются равными (equals() возвращает true), могут иметь разные хеш-коды, 
из-за чего они попадут в разные "корзины" хеш-таблицы.
* Это может привести к тому, что объект, добавленный в HashMap или HashSet, 
не будет найден при повторном поиске с эквивалентным ключом.
* Нарушается эффективность работы хеш-коллекций, 
увеличивается число коллизий и падает производительность.

Поэтому, если переопределяется `equals()`, всегда нужно переопределять `hashCode()`, 
чтобы равные объекты имели одинаковый хеш-код.

```text
***** из методички *****
Нарушится контракт. Классы и методы, которые использовали правила этого контракта 
могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, 
которая была помещена в Map возможно не будет найдена в ней при обращении к Map, 
если используется новый экземпляр ключа.
```
---
</details>



<details>
        <summary>86. Какой контракт между hashCode() и equals()?</summary>

Контракт между `hashCode()` и `equals()` в Java гласит:

1. Если два объекта **не равны** по `equals()`, то их `hashCode()` **может быть разным или одинаковым**.
2. Если два объекта **равны** по `equals()`, то их `hashCode()` **обязательно должен быть одинаковым**.
3. Если `hashCode()` у двух объектов **разный**, то `equals()` **точно вернёт** `false`.
4. Если `hashCode()` у двух объектов **одинаковый**, `equals()` может вернуть как `true`, 
так и `false` (_это возможно из-за коллизий_).
5. Если `equals()` переопределён, то **всегда нужно переопределять** и `hashCode()`, 
иначе коллекции, основанные на хешировании (`HashMap`, `HashSet`), могут работать некорректно.

```text
***** из методички *****
1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны
2) Если equals объектов true, то и хэшкоды должны быть равны.  
3) Переопределив equals, всегда переопределять и hashcode."
```
---
</details>



<details>
        <summary>87. Для чего нужен метод hashCode()?</summary>

Метод `hashCode()` используется для генерации хеш-кода объекта, который играет ключевую роль 
в оптимизированном доступе к данным в коллекциях, 
основанных на хешировании (`HashMap`, `HashSet`, `HashTable`).

Основные задачи метода `hashCode()`:

* Обеспечение **быстрого поиска** объектов в структурах данных.
* **Оптимизация производительности** работы хеш-коллекций, уменьшая количество сравнений в `equals()`.
* Гарантия соблюдения контракта `hashCode()` и `equals()`, 
что предотвращает ошибки при хранении и извлечении объектов.

Важно, чтобы правильно переопределённый `hashCode()` обеспечивал 
**равные хеш-коды для равных объектов** и минимизировал коллизии (_разным объектам – разные хеш-коды_).

```text
***** из методички *****
вычисляет целочисленное значение для конкретного элемента класса, 
чтобы использовать его для быстрого поиска и доступа к этому элементу 
в hash-структурах данных, например, HashMap, HashSet и прочих.
```
---
</details>



<details>
        <summary>88. - Правила переопределения метода hashcode().</summary>

Правила переопределения метода `hashCode()`:

1. **Стабильность** – вызов `hashCode()` на одном и том же объекте 
всегда должен возвращать одно и то же значение, если состояние объекта не изменилось.
2. **Связь с** equals() – если два объекта равны (`equals() == true`), их `hashCode()` должен быть одинаковым.
3. **Разные объекты – разные хеш-коды** – если два объекта не равны, их `hashCode()` 
желательно должен быть разным (_но не обязательно_).
4. **Использование тех же полей, что и в** equals() – хеш-код должен вычисляться на основе полей, 
участвующих в сравнении `equals()`, чтобы избежать несоответствий.
5. **Минимизация коллизий** – разные объекты должны по возможности давать 
разные хеш-коды для эффективной работы хеш-коллекций (`HashMap`, `HashSet`).

Правильная реализация `hashCode()` помогает избежать проблем с потерей объектов 
в хеш-структурах и улучшает их производительность.

```text
***** из методички *****
"Если хеш-коды разные, то и входные объекты гарантированно разные.
Если хеш-коды равны, то входные объекты не всегда равны.
При вычислении хэш-кода следует использовать те же поля, 
которые сравниваются в equals и которые не вычисляются на основе других значений.

- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать 
одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, 
если эти объекты равны (вызов метода equals для этих объектов возвращает true).
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать 
разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, 
что его выполнение положительно повлияет на производительность работы хэш-таблиц."
```
---
</details>



<details>
        <summary>89. _рекомендации при подсчете hashCode()</summary>

**Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете `hashCode()`?**

Рекомендации по выбору полей для `hashCode()`:
* **Использовать уникальные поля** – лучше всего подходят поля, 
которые с высокой вероятностью будут различаться у разных объектов (`id`, `uuid`).
* **Отдавать предпочтение примитивным типам** – такие поля обеспечивают 
стабильный и предсказуемый расчет хеш-кода (`int`, `long`, `boolean`).
* **Использовать те же поля, что и в** `equals()` – чтобы избежать нарушений 
контракта между `equals()` и `hashCode()`.
* **Не использовать изменяемые поля** – поля, которые могут изменяться после создания объекта, 
могут привести к непредсказуемому поведению в хеш-коллекциях (`HashMap`, `HashSet`).
* **Сбалансированность значений** – если используются несколько полей, их комбинация 
должна давать **равномерное распределение хеш-кодов** (_например, с помощью умножения на простые числа_).

```text
***** из методички *****
Выбирать поля, которые с большой долью вероятности будут различаться. 
Для этого необходимо использовать уникальные, лучше всего примитивные поля, 
например такие как id, uuid. При этом нужно следовать правилу, 
если поля задействованы при вычислении hashCode(), 
то они должны быть задействованы и при выполнении equals().
"
```
---
</details>



<details>
        <summary>90. Могут ли у разных объектов быть одинаковые hashCode()?</summary>

У **разных** объектов могут быть **одинаковые** `hashCode()`. Это называется **коллизией**.

Коллизии неизбежны, так как `hashCode()` возвращает `int`, а возможных объектов значительно больше, 
чем **2³²** различных значений `int`.

Важно, чтобы `hashCode()` был распределен равномерно, минимизируя количество коллизий, 
но полностью избежать их невозможно. Коллекции, такие как `HashMap` и `HashSet`, обрабатывают коллизии 
с помощью связных списков (_до Java 8_) или сбалансированных деревьев (_с Java 8_) внутри бакетов.

```text
***** из методички *****
Когда у разных объектов одинаковые хеш-коды называется — коллизией.
```
---
</details>



<details>
        <summary>91. _реализовать hashcode(), уникальным для каждого объекта?</summary>

**Почему нельзя реализовать` hashcode()` который будет гарантированно уникальным для каждого объекта?**

Гарантированно уникальный `hashCode()` **невозможен**, так как `int` содержит лишь **2³²** значений, 
а возможных объектов **бесконечно** много. Это приводит к коллизиям.

```text
***** из методички *****
"В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено.
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть"
```
---
</details>



<details>
        <summary>92. формирование хэш-код</summary>

**Есть класс `Point{int x, y;}`. Почему хэш-код в виде `31 * x + y` предпочтительнее чем `x + y`?**

Использование множителя (_например, **31**_) делает хэш-код более равномерно распределённым, 
уменьшая вероятность коллизий и улучшая производительность хеш-структур.

```text
***** из методички *****
Множитель создает зависимость значения хэш-кода от очередности обработки полей, 
а это дает гораздо лучшую хэш-функцию.
```
---
</details>



<details>
        <summary>93. Чем a.getClass().equals(A.class) отличается от a instanceOf A.class</summary>

**Чем `a.getClass().equals(A.class)` отличается от a `instanceOf A.class`**

* `a.getClass().equals(A.class)` проверяет, принадлежит ли объект **строго указанному классу**, 
без учета наследования.

* a `instanceof A` проверяет, является ли объект **экземпляром** указанного класса **или его потомка**.

```text
***** из методички *****
getClass() получает только класс, а оператор instanceof проверяет 
является ли объект экземпляром класса или его потомком
```
---
</details>

[>>> **NEXT** > _Следующая страница_ >>>](/ITM/ITM01_Core1/5_Core1_Exceptions.md)








<details>
        <summary>Head</summary>

```text
***** из методички *****
```
---
</details>



---

## Дополнительная информация по теме:

Статья на тему: [Архитектура JVM](https://nuancesprog.ru/p/15245/) ([вопрос 56](#архитектура-jvm)) 
([вопрос 56](######56.-_классы-загрузчики-и-_динамическая-загрузка-классов))

<details>
        <summary>sealed классы</summary>

Введены в **Java 15** (_в предварительном виде_) и окончательно закреплены в **Java 17**. 

Они позволяют **явно контролировать**, какие классы могут наследоваться от данного класса, 
улучшая инкапсуляцию и безопасность кода.

🔹 Что такое **sealed классы**?
Обычно в Java любой класс можно унаследовать, если он не является final. 
Однако sealed (запечатанный) класс позволяет ограничить круг подклассов. 
Это полезно, когда вы хотите разрешить наследование только определённым классам.

🔹 Как объявить **sealed класс**?
При объявлении sealed класса нужно использовать ключевое слово permits, 
чтобы указать допустимые подклассы.

```java
public sealed class Animal permits Dog, Cat, Bird { 
    // код класса
}
```
Здесь `Animal` — запечатанный класс, и **только** `Dog`, `Cat` и `Bird` могут от него наследоваться.

🔹 Возможные подклассы
Классы, которые наследуют sealed класс, должны явно указать, как они себя ведут в плане наследования. 
Они могут быть:

1. `final` – запрещает дальнейшее наследование.
2. `sealed` – продолжает ограниченное наследование.
3. `non-sealed` – снимает ограничения, позволяя наследование без ограничений.

Пример:
```java
public final class Dog extends Animal { }  // нельзя унаследовать дальше

public sealed class Cat extends Animal permits PersianCat { }  // продолжает sealed-ограничения
public non-sealed class Bird extends Animal { }  // открывает наследование
```

🔹 Когда использовать sealed классы?
* ✅ Когда нужно контролировать иерархию наследования.
* ✅ Когда нужно улучшить безопасность кода.
* ✅ Когда разрабатываете API или библиотеку и хотите избежать нежелательных подклассов.

🔹 Отличия от других модификаторов:
![Отличия от других модификаторов](/ITM/ITM01_Core1/imgs/2025-02-25_15-57-31.png)

🔹 Пример с использованием instanceof
Так как sealed классы ограничивают подклассы, они отлично работают 
с instanceof и **pattern matching**:
```java
static void processAnimal(Animal animal) {
    switch (animal) {
        case Dog d -> System.out.println("This is a Dog");
        case Cat c -> System.out.println("This is a Cat");
        case Bird b -> System.out.println("This is a Bird");
    }
}
```
Здесь `switch` проверяет все возможные подклассы `Animal`, и компилятор знает, 
что **других вариантов быть не может**.

🔹 Итог:
`sealed` классы — это мощный инструмент для создания безопасных 
и контролируемых иерархий в Java. 
Они позволяют избежать нежелательного наследования и улучшают поддержку switch-выражений.

---
</details>

