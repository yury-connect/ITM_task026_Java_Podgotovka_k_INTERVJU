
---

## ООП 

<details>
        <summary> 1. Что такое ООП</summary>

**ООП** (`объектно-ориентированное программирование`) — это парадигма программирования, 
основанная на использовании **объектов**, которые объединяют данные и **методы** для их обработки. 

Основные принципы: 
* **инкапсуляция**, 
* **наследование**, 
* **полиморфизм** и 
* **абстракция**.

```text

***** из методички *****
"ООП" - методология программирования, основанная на представлении программы в виде совокупности объектов, 
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, 
единственный способ изменить состояние объекта - передать ему сообщение,  в ответ на которое, 
объект может изменить собственное состояние.

Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, 
а объект – экземпляр класса, созданный на основе этого описания."
```
---
</details>



<details>
        <summary>2. Какие преимущества у ООП?</summary>

> * **Читаемость** – код структурирован, легче понимать назначения функций.
> 
> * **Быстрая разработка** – удобное создание и использование объектов.
> 
> * **Масштабируемость** – проще реализовать сложный функционал.
> 
> * **Минимизация дублирования** – повторяющийся код выносится в классы.

```text
***** из методички *****
 * Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают
 * Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.
 * Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, 
можно гораздо быстрее создать приложение с множеством возможностей
 * Меньше повторений кода - не нужно писать однотипные функции для разных сущностей
```
---
</details>



<details>
        <summary>3. Какие недостатки у ООП?</summary>

> * **Повышенное потребление ресурсов** – дополнительные абстракции снижают производительность.
> 
> * **Сложность освоения** – требует больше времени на изучение.
> 
> * **Избыточность кода** – из-за классов и объектов программа может становиться громоздкой.
> 

```text
***** из методички *****
* Меньше повторений кода - не нужно писать однотипные функции для разных сущностей
* Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
* Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени
```
---
</details>



<details>
        <summary>4. Назовите основные принципы ООП</summary>

> * **Инкапсуляция** – скрытие деталей реализации и управление доступом.
>
> * **Наследование** – создание новых классов на основе существующих.
>
> * **Полиморфизм** – единый интерфейс для разных типов объектов.
>
> * **Абстракция** – выделение ключевых характеристик и скрытие несущественных деталей.
> 

```text
***** из методички *****
Инкапсуляция
Наследование 
Полиморфизм
```
---
</details>



<details>
        <summary>5. Что такое инкапсуляция? (С примером)"</summary>

**Инкапсуляция** – объединение **данных** и **методов**, работающих с ними, в **одном** объекте, 
что защищает их от внешнего вмешательства и ошибок. 

Это позволяет изменять внутренности класса 
без влияния на его использование снаружи.

```text
***** из методички *****
Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, 
а также защищает и то, и другое от внешнего вмешательства или неправильного использования. 

Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»). 

Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса
```
---
</details>



<details>
        <summary>6. Что такое наследование? (С примером)"</summary>

**Наследование** – возможность создания **нового** класса на основе **существующего**,   
при этом новый класс может **наследовать** его свойства и методы, 
**расширяя** или **изменяя** их.

```text
***** из методички *****
Свойство системы, которое позволяет описать новый класс 
на основе уже существующего с частично или полностью заимствованной функциональностью.
```
---
</details>



<details>
        <summary>7. Что такое полиморфизм? (С примером)</summary>

**Полиморфизм** – способность использовать объекты с **одинаковым интерфейсом**, 
не зная их точного **типа** и **внутренней структуры**.    
Это упрощает код, позволяя выполнять **одинаковые** действия с **разными** объектами. 

**Полиморфизм** – позволяет объектам разных классов быть обработанными единообразным способом.

**Полиморфизм** бывает:

* **Динамическим** (_**переопределение** или Полиморфизм времени выполнения_) – поведение 
объектов меняется в зависимости от их **типа**.
* **Статическим** (_**перегрузка** или Полиморфизм компиляции_) – **одна** функция 
работает с **разными** типами данных.
Он позволяет изменять поведение объектов, даже если они обращаются через общий интерфейс.

_Полиморфная **переменная**, это переменная, которая может принимать значения разных типов,   
а полиморфная **функция**, это функция у которой хотя бы один аргумент является полиморфной переменной._

* **Ковариантность типов** - позволяет использовать объекты **производных** классов 
там, где требуется объект **базового** класса.

```text
***** из методички *****
"Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом 
без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, 
разрешая использование одного и того же интерфейса для задания единого набора действий. 
Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. 
Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, 
вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним 
будет производиться по ссылке родительского типа).

Полиморфизм бывает динамическим (переопределение) и статическим (перегрузка).

Полиморфная переменная, это переменная, которая может принимать значения разных типов, 
а полиморфная функция, это функция у которой хотя бы один аргумент является полиморфной переменной. 

Выделяют два вида полиморфных функций:

* ad hoc, функция ведет себя по разному для разных типов аргументов 
(например, функция draw() — рисует по разному фигуры разных типов);

* параметрический, функция ведет себя одинаково для аргументов разных типов 
(например, функция add() — одинаково кладет в контейнер элементы разных типов)."
```
---
</details>



<details>
        <summary>8. Что такое ассоциация</summary>

**Ассоциация** – это связь между объектами двух классов, позволяющая им взаимодействовать друг с другом. 
Объекты могут **ссылаться** друг на друга, но при этом остаются **независимыми**.

**Разновидности ассоциации**:

* **Агрегация** – слабая связь, где один объект **может** существовать без другого (_например, команда и игрок_).
* **Композиция** – сильная связь, где один объект **не может** существовать без другого (_например, дом и комнаты_).

![ассоциация](/ITM/ITM01_Core1/imgs/2025-03-03_18-56-51.png)

**Отношения между классами**
![Отношения между классами](/ITM/ITM01_Core1/imgs/2025-03-03_18-55-00.png)


```text
***** из методички *****
Есть два типа связи между объектами: ассоциация, которая делится на композицию и агрегацию, и наследование.
Ассоциация - обозначает связь между объектами. Например, игрок играет в определенной команде.

Ассоциация означает, что объекты двух классов могут ссылаться один на другой, 
иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. 
Соответственно возникает ассоциация между Менеджером и Счетом. 
Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. 
Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. 
Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.

http://java-course.ru/begin/relations/
```
    [ссылка](http://java-course.ru/begin/relations/")

---
</details>



<details>
        <summary>9. Что такое композиция?</summary>

**Композиция** – это **жесткая** связь между объектами, где один объект является **неотъемлемой** частью другого 
и **не может** существовать отдельно.

Главные характеристики:

* **Зависимость жизненного цикла**: при удалении главного объекта удаляется и зависимый.
* **Полное управление**: главный объект создает и контролирует подчиненный.

**Пример**: _автомобиль и его двигатель – двигатель принадлежит конкретному автомобилю и уничтожается вместе с ним._

```text
***** из методички *****
Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, 
но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. 
Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. 
В отличии от студента, который может входить и в другие группы тоже. 

Например, в класс автомобиля содержит объект класса электрического двигателя:"
"public class ElectricEngine{ }
 
public class Car {
    ElectricEngine engine;
    public Car()
    {
        engine = new ElectricEngine();
    }
}"
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. 
При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. 
И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.
```
---
</details>



<details>
        <summary>10. Что такое агрегация?</summary>

**Агрегация** – это **слабая** связь между объектами, где один объект **может** существовать независимо от другого.

Главные особенности:

* Отношение "**имеет**" (_HAS-A_), но **без** жесткой зависимости.
* Зависимый объект может принадлежать **нескольким** владельцам или существовать отдельно.

**Пример**: _университет и студенты – студент может учиться в университете, но остается самостоятельной сущностью._

```text
***** из методички *****
Агрегация определяет отношение HAS A, но связь слабее чем в композиции, т.к. обьекты равноправны.
```
---
</details>



<details>
        <summary>11. Расскажите про раннее и позднее связывание.</summary>

**Раннее и позднее связывание** относятся к моменту, когда устанавливается связь 
между **вызовом метода** и его **реализацией**.

* **Раннее связывание** (_early binding_) – происходит на этапе **компиляции**.    
Метод известен компилятору, и связь с ним устанавливается заранее.    
Применяется для статических, приватных и финальных методов, а также перегрузок.

* **Позднее связывание** (_late binding_) – устанавливается во время **выполнения** программы.    
Компилятор **не может** заранее определить, какой метод будет вызван.     
Это используется для **переопределенных методов**, а также через **рефлексию**.

При **раннем** связывании используется **тип** переменной,    
а при **позднем** — конкретный **объект**.

```text
***** из методички *****
Связывание есть наличие связи между вызываемым методом программы и написанным кодом.

Ранее связывание
Если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding), 
также называют статическим связыванием.

Позднее связывание (late binding) - вызов метода возможен только во время выполнения, 
т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. 
В java это возможно при помощи рефлексии.

Статическое связывание используется для final, перегруженных, приватных, статических методов, 
в то время как динамическое связывание используется для разрешения переопределенных методов. 
Все абстрактные методы разрешаются при помощи динамического связывания.

В случае статического связывания используются не конкретные объекты, а информация о типе, 
то есть используется тип ссылочной переменной. 
С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.
```
---
</details>



<details>
        <summary>12. SOLID</summary>

> **SOLID** – акроним, представляющий пять принципов объектно-ориентированного проектирования:
>
> * **S (_Single Responsibility Principle_)** – принцип **единственной ответственности**: класс должен решать 
только **одну** задачу, что облегчает модификацию и тестирование.
> 
> * **O (_Open/Closed Principle_)** – принцип **открытости/закрытости**: классы должны быть **открыты 
для расширения**, но **закрыты для модификации**.
> 
> * **L (_Liskov Substitution Principle_)** – принцип **подстановки _Барбары Лисков_**: объекты наследников 
должны **заменять** объекты базового класса **без изменения** поведения программы.
> 
> * **I (_Interface Segregation Principle_)** – принцип **разделения интерфейса**: лучше использовать 
**несколько специализированных** интерфейсов, чем **один универсальный**.
> 
> * **D (_Dependency Inversion Principle_)** – принцип **инверсии зависимостей**: модули должны зависеть 
**от абстракций**, а **не от конкретных реализаций**.
> 

Эти принципы помогают создавать гибкий, расширяемый и легко поддерживаемый код.

```text
***** из методички *****
SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. 

S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну 
задачу. 
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.

O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения 
и закрыты для модификации.
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, 
и используем свой класс.

L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе 
можно заменить их наследниками без изменения свойств программы.

I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных 
интерфейсов лучше, чем один общий

D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. 
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны 
зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) 
и разные карты оплаты.
```
---
</details>










---

<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>
