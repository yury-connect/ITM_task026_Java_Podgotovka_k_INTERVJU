
---

## ООП 

<details>
        <summary> 1. Что такое ООП</summary>

**ООП** (объектно-ориентированное программирование) — это парадигма программирования, 
основанная на использовании объектов, которые объединяют данные и методы для их обработки. 

Основные принципы: **инкапсуляция**, **наследование**, **полиморфизм** и **абстракция**.

```text

***** из методички *****
"ООП" - методология программирования, основанная на представлении программы в виде совокупности объектов, 
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, 
единственный способ изменить состояние объекта - передать ему сообщение,  в ответ на которое, 
объект может изменить собственное состояние.

Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, 
а объект – экземпляр класса, созданный на основе этого описания."
```
</details>



<details>
        <summary>2. Какие преимущества у ООП?</summary>

> **Читаемость** – код структурирован, легче понимать назначения функций.
> 
> **Быстрая разработка** – удобное создание и использование объектов.
> 
> **Масштабируемость** – проще реализовать сложный функционал.
> 
> **Минимизация дублирования** – повторяющийся код выносится в классы.

```text
***** из методички *****
 * Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают
 * Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.
 * Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, 
можно гораздо быстрее создать приложение с множеством возможностей
 * Меньше повторений кода - не нужно писать однотипные функции для разных сущностей
```
</details>



<details>
        <summary>3. Какие недостатки у ООП?</summary>

> **Повышенное потребление ресурсов** – дополнительные абстракции снижают производительность.
> 
> **Сложность освоения** – требует больше времени на изучение.
> 
> **Избыточность кода** – из-за классов и объектов программа может становиться громоздкой.
> 

```text
***** из методички *****
* Меньше повторений кода - не нужно писать однотипные функции для разных сущностей
* Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
* Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени
```
</details>



<details>
        <summary>4. Назовите основные принципы ООП</summary>

> **Инкапсуляция** – скрытие деталей реализации и управление доступом.
>
> **Наследование** – создание новых классов на основе существующих.
>
> **Полиморфизм** – единый интерфейс для разных типов объектов.
>
> **Абстракция** – выделение ключевых характеристик и скрытие несущественных деталей.
> 

```text
***** из методички *****
Инкапсуляция
Наследование 
Полиморфизм
```
</details>



<details>
        <summary>5. Что такое инкапсуляция? (С примером)"</summary>

**Инкапсуляция** – объединение данных и методов, работающих с ними, в одном объекте, 
что защищает их от внешнего вмешательства и ошибок. 

Это позволяет изменять внутренности класса 
без влияния на его использование снаружи.

```text
***** из методички *****
Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, 
а также защищает и то, и другое от внешнего вмешательства или неправильного использования. 

Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»). 

Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса
```
</details>



<details>
        <summary>6. Что такое наследование? (С примером)"</summary>

Наследование – возможность создания нового класса на основе существующего, 
при этом новый класс может наследовать его свойства и методы, расширяя или изменяя их.


```text
***** из методички *****
Свойство системы, которое позволяет описать новый класс 
на основе уже существующего с частично или полностью заимствованной функциональностью.
```
</details>



<details>
        <summary>7. Что такое полиморфизм? (С примером)"</summary>

**Полиморфизм** – способность использовать объекты с одинаковым интерфейсом, 
не зная их точного типа и внутренней структуры. Это упрощает код, 
позволяя выполнять одинаковые действия с разными объектами. 

**Полиморфизм** бывает:

* **Динамическим** (_переопределение_) – поведение объектов меняется в зависимости от их типа.
* **Статическим** (_перегрузка_) – одна функция работает с разными типами данных.
Он позволяет изменять поведение объектов, даже если они обращаются через общий интерфейс.
* 
```text
***** из методички *****
"Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом 
без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, 
разрешая использование одного и того же интерфейса для задания единого набора действий. 
Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. 
Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, 
вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним 
будет производиться по ссылке родительского типа).

Полиморфизм бывает динамическим (переопределение) и статическим (перегрузка).

Полиморфная переменная, это переменная, которая может принимать значения разных типов, 
а полиморфная функция, это функция у которой хотя бы один аргумент является полиморфной переменной. 

Выделяют два вида полиморфных функций:

* ad hoc, функция ведет себя по разному для разных типов аргументов 
(например, функция draw() — рисует по разному фигуры разных типов);

* параметрический, функция ведет себя одинаково для аргументов разных типов 
(например, функция add() — одинаково кладет в контейнер элементы разных типов)."
```
</details>



<details>
        <summary>8. Что такое ассоциация</summary>

**Ассоциация** – это связь между объектами двух классов, позволяющая им взаимодействовать друг с другом. 
Объекты могут ссылаться друг на друга, но при этом остаются независимыми.

Разновидности ассоциации:

**Агрегация** – слабая связь, где один объект может существовать без другого (_например, команда и игрок_).
**Композиция** – сильная связь, где один объект не может существовать без другого (_например, дом и комнаты_).

```text
***** из методички *****
Есть два типа связи между объектами: ассоциация, которая делится на композицию и агрегацию, и наследование.
Ассоциация - обозначает связь между объектами. Например, игрок играет в определенной команде.

Ассоциация означает, что объекты двух классов могут ссылаться один на другой, 
иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. 
Соответственно возникает ассоциация между Менеджером и Счетом. 
Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. 
Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. 
Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.

http://java-course.ru/begin/relations/
```
    [ссылка](http://java-course.ru/begin/relations/")
</details>



<details>
        <summary>9. Что такое композиция?</summary>

**Композиция** – это жесткая связь между объектами, где один объект является неотъемлемой частью другого 
и не может существовать отдельно.

Главные характеристики:

* Зависимость жизненного цикла: при удалении главного объекта удаляется и зависимый.
* Полное управление: главный объект создает и контролирует подчиненный.

Пример: автомобиль и его двигатель – двигатель принадлежит конкретному автомобилю и уничтожается вместе с ним.

```text
***** из методички *****
Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, 
но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. 
Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. 
В отличии от студента, который может входить и в другие группы тоже. 

Например, в класс автомобиля содержит объект класса электрического двигателя:"
"public class ElectricEngine{ }
 
public class Car {
    ElectricEngine engine;
    public Car()
    {
        engine = new ElectricEngine();
    }
}"
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. 
При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. 
И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.
```
</details>



<details>
        <summary>10. Что такое агрегация?</summary>

**Агрегация** – это слабая связь между объектами, где один объект может существовать независимо от другого.

Главные особенности:

* Отношение "имеет" (HAS-A), но без жесткой зависимости.
* Зависимый объект может принадлежать нескольким владельцам или существовать отдельно.

Пример: университет и студенты – студент может учиться в университете, но остается самостоятельной сущностью.

```text
***** из методички *****
Агрегация определяет отношение HAS A, но связь слабее чем в композиции, т.к. обьекты равноправны.
```
</details>



<details>
        <summary>11. Расскажите про раннее и позднее связывание.</summary>

**Раннее и позднее связывание** относятся к моменту, когда устанавливается связь 
между вызовом метода и его реализацией.

* **Раннее связывание** (_early binding_) – происходит на этапе `компиляции`. Метод известен компилятору, и связь с ним устанавливается заранее. Применяется для статических, приватных и финальных методов, а также перегрузок.
* **Позднее связывание** (_late binding_) – устанавливается во время `выполнения` программы. 
Компилятор не может заранее определить, какой метод будет вызван. 
Это используется для переопределенных методов, а также через рефлексию.

При раннем связывании используется тип переменной, а при позднем — конкретный объект.

```text
***** из методички *****
Связывание есть наличие связи между вызываемым методом программы и написанным кодом.

Ранее связывание
Если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding), 
также называют статическим связыванием.

Позднее связывание (late binding) - вызов метода возможен только во время выполнения, 
т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. 
В java это возможно при помощи рефлексии.

Статическое связывание используется для final, перегруженных, приватных, статических методов, 
в то время как динамическое связывание используется для разрешения переопределенных методов. 
Все абстрактные методы разрешаются при помощи динамического связывания.

В случае статического связывания используются не конкретные объекты, а информация о типе, 
то есть используется тип ссылочной переменной. 
С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.
```
</details>



<details>
        <summary>12. SOLID</summary>

> **SOLID** – акроним, представляющий пять принципов объектно-ориентированного проектирования:
>
> * **S (Single Responsibility Principle)** – принцип единственной ответственности: класс должен решать 
только одну задачу, что облегчает модификацию и тестирование.
> 
> * **O (Open/Closed Principle)** – принцип открытости/закрытости: классы должны быть открыты 
для расширения, но закрыты для модификации.
> 
> * **L (Liskov Substitution Principle)** – принцип подстановки Барбары Лисков: объекты наследников 
должны заменять объекты базового класса без изменения поведения программы.
> * **I (Interface Segregation Principle)** – принцип разделения интерфейса: лучше использовать 
несколько специализированных интерфейсов, чем один универсальный.
> 
> * **D (Dependency Inversion Principle)** – принцип инверсии зависимостей: модули должны зависеть 
от абстракций, а не от конкретных реализаций.
> 

Эти принципы помогают создавать гибкий, расширяемый и легко поддерживаемый код.

```text
***** из методички *****
SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. 

S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну 
задачу. 
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.

O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения 
и закрыты для модификации.
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, 
и используем свой класс.

L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе 
можно заменить их наследниками без изменения свойств программы.

I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных 
интерфейсов лучше, чем один общий

D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. 
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны 
зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) 
и разные карты оплаты.
```
</details>













---
## Java


<details>
        <summary>13. Какая основная идея языка?</summary>

Основная идея Java – **"Написано однажды – работает везде"**. Это означает, что код, написанный на Java, 
может выполняться на любой платформе без изменений, благодаря использованию виртуальной машины _(JVM)_.

```text
***** из методички *****
"«Написано однажды - работает везде».
Идея основывается в написании одного кода, который будет работать на любой платформе."
```
</details>



<details>
        <summary>14. За счет чего обеспечивается кроссплатформенность?</summary>

**Кроссплатформенность** Java обеспечивается благодаря Java Virtual Machine (JVM). 
JVM является промежуточным слоем между операционной системой и программой на Java, 
что позволяет выполнять байт-код Java на любой платформе, где установлена JVM. 
Это устраняет необходимость перекомпиляции кода для разных операционных систем.

```text
***** из методички *****
"Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. 

Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой 
и Java программой. В среде виртуальной машины выполняются коды Java программ. 
Сама JVM реализована для разных ОС.
Что байт код для JVM может исполняться везде где установлена JVM.
Код не нужно перекомпилировать под каждую из платформ."
```
</details>



<details>
        <summary>15. Какие преимущества у java?</summary>

**Преимущества Java**:

> **Объектно-ориентированное программирование** – объекты управляют данными и их взаимодействием, 
упрощая структуру программы.
> 
> **Простой синтаксис** – Java легче для изучения, чем C++, что ускоряет процесс обучения.
> 
> **Стандарт для корпоративных систем** – Java зарекомендовала себя как надежный инструмент 
для разработки корпоративных приложений.
> 
> **Безопасность** – отсутствие указателей и наличие Security Manager для контроля доступа.
> 
> **Кроссплатформенность** – код компилируется в байт-код, который работает на любой платформе 
с установленной JVM.
> 
> **Распределенное программирование** – поддержка RMI и других методов для работы с распределенными 
вычислениями.
> **Автоматическое управление памятью** – сборщик мусора управляет памятью 
без вмешательства разработчика.
> 
> **Многопоточность** – возможность эффективного использования процессора 
через параллельное выполнение потоков.
> 
> **Стабильность и сообщество** – сильная поддержка и активное сообщество разработчиков.
> 

```text
***** из методички *****
"Объектно-ориентированное программирование   
- структура данных становится объектом, которым можно управлять для создания отношений 
между различными объектами.

Язык высокого уровня с простым синтаксисом и плавной кривой обучения 
- синтаксис Java основан на C ++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, 
что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.

Стандарт для корпоративных вычислительных систем
- корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали 
искать надежные инструменты программирования не на C.

Безопасность 
- благодарю отсутсвию указателей и Security Manager (политика безопасности, 
в которой можно указать правила доступа, позволяет запускать приложения Java в ""песочнице"").

Независимость от платформы 
- Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его 
на любой другой платформе, поддерживающей виртуальную машину Java (JVM). 
Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.

Язык для распределенного программирования и комфортной удаленной совместной работы
- Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). 
RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы 
и объектно-ориентированное программирование для распределенных вычислений. 
Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA 
для обмена объектами между программами, написанными на разных языках.

Автоматическое управление памятью
Разработчикам Java не нужно вручную писать код для управления памятью благодаря 
автоматическому управлению памятью (AMM).

Многопоточность
Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать 
время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.

Стабильность и сообщество
Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 
используют Java."
```
</details>



<details>
        <summary>16. Какие недостатки у java?</summary>

**Недостатки Java**:

>
> **Платное коммерческое использование** (с 2019 года) – лицензирование требует затрат 
для некоторых видов использования.
>
> **Низкая производительность** – из-за использования JVM и сборщика мусора, 
что может замедлить выполнение приложений.
>
> **Неудобные инструменты для GUI** – создание графических интерфейсов на чистой Java ограничено.
>
> **Многословность кода** – язык требует большего количества кода для выполнения операций 
по сравнению с более компактными языками.
> 

```text
***** из методички *****
"Платное коммерческое использование (с 2019)

Низкая производительность
из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.

Не развитые инструменты по созданию GUI приложений на чистой java.

Многословный код
Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать 
свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, 
но менее компактным."
```
</details>



<details>
        <summary>17. Что такое JDK? Что в него входит?</summary>

**JDK (Java Development Kit)** – это набор инструментов для разработки приложений на языке Java. Включает в себя:

>
> **JRE** (Java Runtime Environment) – среда выполнения Java.
>
> **Компилятор** (javac) – для компиляции исходного кода Java.
>
> **Стандартные библиотеки классов** – набор готовых классов для работы с основными функциями.
>
> **Примеры и документация** – образцы кода и справочные материалы для разработчиков.
>
> **Утилиты** – различные инструменты для разработки и отладки приложений.

```text
***** из методички *****
"JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:
- компилятор Java (javac)
- стандартные библиотеки классов java
- примеры
- документацию
- различные утилиты"
```
</details>



<details>
        <summary>18. Что такое JRE? Что в него входит?</summary>

**JRE (Java Runtime Environment)** – это минимальная среда для запуска Java-приложений. Включает:

>
> **JVM** (Java Virtual Machine) – виртуальная машина для выполнения байт-кода Java.
>
> **ClassLoader** – компонент для загрузки классов в память.
>
> **Стандартные библиотеки и классы Java** – набор готовых классов для выполнения различных задач.
> 

```text
***** из методички *****
JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения 
Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java
```
</details>



<details>
        <summary>19. Что такое JVM?</summary>

**JVM (Java Virtual Machine)** – виртуальная машина, которая выполняет байт-код Java, 
преобразованный JIT-компилятором.

Основные функции:

> * Интерпретация и выполнение байт-кода.
> 
> * Управление памятью _(включая сборку мусора)_.
> 
> * Обеспечение кроссплатформенности Java.

Одна из популярных реализаций JVM – **HotSpot**.
```text
***** из методички *****
JVM (Java Virtual Machine) - виртуальная машина Java исполняет байт-код Java, предварительно созданный 
из кода JIT компилятором, с помощью встроенного интерпретатора байт-кода.
HotSpot представляет собой реализацию концепции JVM.
```
</details>



<details>
        <summary>20. Что такое byte code?</summary>

**Байт-код Java** – это промежуточный набор инструкций, скомпилированный из исходного кода Java, 
который выполняется **JVM**. 

Он делает Java кроссплатформенной, так как может исполняться 
на любой системе с установленной виртуальной машиной.

```text
***** из методички *****
Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM. 
```
</details>



<details>
        <summary>21. Что такое загрузчик классов (classloader)?</summary>

**ClassLoader** _(загрузчик классов)_ – компонент **JVM**, 
загружающий скомпилированный **байт-код** Java-классов в память.

**Основные загрузчики:**

> * **Bootstrap ClassLoader** – загружает базовые классы JDK.
> 
> * **AppClassLoader** – загружает классы приложения из **CLASSPATH**.
> 
> * **Extension ClassLoader** _(до Java 9)_ – загружал классы расширений.
> 

**Этапы работы:**

> 1. **Загрузка** – поиск и импорт байт-кода.
> 2. **Связывание**:
> > * **Проверка** – проверка корректности кода.
> > * **Подготовка** – выделение памяти и инициализация значениями по умолчанию.
> > * **Разрешение** – преобразование символических ссылок в реальные.
> 3. **Инициализация** – выполнение кода для установки окончательных значений переменных.

ClassLoader использует **иерархическую модель** – каждый загрузчик передает загрузку родительскому, 
если не может обработать её сам.
```text
***** из методички *****
Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class

При запуске JVM, используются три загрузчика классов:
- Bootstrap ClassLoader - базовый загрузчик
- загружает платформенные классы JDK из архива rt.jar

- AppClassLoader - системный загрузчик
- загружает классы приложения, определенные в CLASSPATH 

- Extension ClassLoader - загрузчик расширений после В Java9 выпилили
- загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.

ClassLoader выполняет три основных действия в строгом порядке:
•        Загрузка: находит и импортирует двоичные данные для типа.
•        Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
 -        Проверка: обеспечивает правильность импортируемого типа.
 -        Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
 -        Разрешение: преобразует символические ссылки из типа в прямые ссылки.
•        Инициализация: вызывает код Java, который инициализирует переменные класса 
их правильными начальными значениями.

Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку 
если сам будет не в состоянии этого сделать.
```
</details>



<details>
        <summary>22. Что такое JIT ?</summary>

**JIT** _(Just-In-Time Compiler)_ – компилятор, который **во время выполнения** программы 
переводит байт-код Java в **машинный код**, ускоряя выполнение.

**Основные функции JIT:**

> * **Повышает производительность** за счёт компиляции часто используемых частей кода.
> 
> * **Оптимизирует код** в реальном времени (инлайн-функции, устранение избыточных вычислений и др.).
> 
> * **Сочетает интерпретацию и компиляцию** для баланса между скоростью и эффективностью.
> 

JIT – ключевой механизм, делающий Java-приложения быстрее без потери кроссплатформенности.
```text
***** из методички *****
JIT (Just-in-time compilation) - компиляция на лету или динамическая компиляция - технология 
увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода 
в машинный код во время работы программы.

В основном отвечает за оптимизацию производительности приложений во время выполнения.
https://javahelp.online/osnovy/voprosy-otvety-sobesedovanie-java (Q13)
```
</details>



<details>
        <summary>23. Что такое сборщик мусора? (Garbage collector)</summary>

**Сборщик мусора** _(Garbage Collector, **GC**)_ – автоматический механизм управления памятью в Java, который:

1. **Находит неиспользуемые объекты** (мусор).
2. **Очищает память** от этих объектов.

> **Методы обнаружения мусора:**
>
> * **Учет ссылок** _(Reference Counting)_ – объект удаляется, если на него нет ссылок (не решает проблему циклических ссылок).
> 
> * **Трассировка** _(Tracing, используется в HotSpot JVM)_ – ищет объекты, доступные из **GC Roots** (всё остальное считается мусором).
>

> **GC Roots в Java:**
>
> * Статические поля классов.
> 
> * Локальные переменные потоков.
> 
> * JNI-ссылки в нативных методах.
>

> **Основные типы сборки мусора:**
>
> * **Minor GC** _(малый)_ – чистит молодое поколение (Eden → Survivor → Old Gen).
> 
> * **Major GC** _(старый)_ – чистит старое поколение (Old Gen) с уплотнением памяти.
> 
> * **Full GC** _(полный)_ – очищает всю кучу (Young + Old Gen), самая затратная операция.
> 

Сборка мусора выполняется с кратковременной паузой Stop-The-World (STW), временно останавливающей приложение.
```text
***** из методички *****
 
"Сборщик мусора выполняет две задачи:
- поиск мусора;
- очистка мусора.

Для обнаружения мусора есть два подхода:"
- Учет ссылок (Reference counting);
"Учет ссылок - если обьект не имеет ссылок, он считается мусором.
Проблема - не возможность выявить циклические ссылки, когда два обьекта не имеют внешних ссылок, 
но ссылаются друг на друга -> утечка памяти"
- Трассировка (Tracing). (используется в HotSpot)6
"Трассировка - до обьекта можно добраться из Корневых точке (GC root). 
До чего добраться нельзя - мусор.
Всё, что доступно из «живого» объекта, также является «живым»."
Типы корневых точек (GC Roots) java приложения:
"- объекты в статических полях классов
- объекты, доступные из стека потоков
- объекты из JNI(java native interface) ссылок в native методах"
"Процессы сборки мусора разделяются несколько видов:
minor GC (малая) - частый и быстрый, работает только с областью памяти ""young generation"";
- приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);
- «живые» объекты из Eden перемещаются в область памяти «To»;
- «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;
- Eden и «From» очищаются от мусора;
- «To» и «From» меняются местами;
- приложение возобновляет работу.
major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения.
В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. 
В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.
full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, 
если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты 
от молодого поколения)."
```
</details>



<details>
        <summary>24. Виды ссылок в Java.</summary>

```text
***** из методички *****
"1) StrongReference — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
        StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder."
"2) SoftReference —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем 
как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, 
когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM 
от завершения работы.
        StringBuilder builder = new StringBuilder();
        SoftReference<StringBuilder> softBuilder = new SoftReference(builder);

1) softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект 
из памяти. В другом случае вернется null.

2) softBuilder.clear() — удалит ссылку на объект StringBuilder
То же самое работает для WeakReference."

3) WeakReference — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), 
то он удалит его из памяти.

4) PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он 
его удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две.
 - Первая это то, что метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл 
использовать только вместе с ReferenceQueue.
 - Вторая особенность – в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку 
в ReferenceQueue после того как выполниться метод finalize().


So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. 
Phantom references don’t free the reference until cleared.

ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. 
Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. 
При создании Reference мы можем передать в конструктор ReferenceQueue, 
в который будут помещаться ссылки после удаления.
```
</details>



<details>
        <summary>25. Виды ссылок в Java</summary>

1. **Strong Reference** _(Сильная ссылка)_
   Обычные ссылки, которые мы создаем в коде. Объекты с такими ссылками не удаляются **GC**, 
пока ссылка на них существует.
```java
StringBuilder builder = new StringBuilder(); // builder - strong reference
```

2. **Soft Reference** _(Мягкая ссылка)_
   **GC** удаляет объекты, доступные только через soft-ссылки **только в случае нехватки памяти** 
(перед выбросом `OutOfMemoryError`). Используются для кэширования.
```java
SoftReference<StringBuilder> softBuilder = new SoftReference<>(new StringBuilder("Hello"));
softBuilder.get();  // Возвращает объект, если он не удален GC
softBuilder.clear(); // Явное удаление ссылки
```

3. **Weak Reference** _(Слабая ссылка)_
   Объекты, доступные **только через weak-ссылки**, удаляются **при первом же запуске GC**.
   Используется в `WeakHashMap` для хранения ключей.
```java
WeakReference<StringBuilder> weakBuilder = new WeakReference<>(new StringBuilder("Hello"));
weakBuilder.get();  // Может вернуть null, если объект удален GC
```
 
4. **Phantom Reference** _(Фантомная ссылка)_
   Не позволяет получить объект (метод `get()` **всегда возвращает null**). Используется для отслеживания 
удаления объектов (например, для управления нативными ресурсами).
   Работает **только** с `ReferenceQueue`.
```java
ReferenceQueue<StringBuilder> queue = new ReferenceQueue<>();
PhantomReference<StringBuilder> phantomBuilder = new PhantomReference<>(new StringBuilder("Hello"), queue);
phantomBuilder.get();  // Всегда возвращает null
```
 
**ReferenceQueue**
Позволяет отслеживать объекты, удаленные GC. Phantom-ссылки добавляются в `ReferenceQueue` 
**после вызова** `finalize()` объекта.

```text
***** из методички *****
1) StrongReference — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
        StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.
        
2) SoftReference —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем 
как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической 
ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти 
и тем самым попробует спасти JVM от завершения работы.
        StringBuilder builder = new StringBuilder();
        SoftReference<StringBuilder> softBuilder = new SoftReference(builder);

softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. 
В другом случае вернется null.
softBuilder.clear() — удалит ссылку на объект StringBuilder
То же самое работает для WeakReference."

3) WeakReference — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), 
то он удалит его из памяти.

"4) PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его 
удалит из памяти. После нескольких запусков GC.
Особенностей у этого типа ссылок две.
Первая это то, что метод get() всегда возвращает null. Именно из-за этого PhantomReference имеет смысл 
использовать только вместе с ReferenceQueue.
Вторая особенность – в отличие от SoftReference и WeakReference, GC добавит phantom-ссылку в ReferenceQueue 
после того как выполниться метод finalize().

So in brief: Soft references try to keep the reference. Weak references don’t try to keep the reference. 
Phantom references don’t free the reference until cleared.

ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. 
Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. 
При создании Reference мы можем передать в конструктор ReferenceQueue, 
в который будут помещаться ссылки после удаления.

```
</details>



<details>
        <summary>26.  Stack и Heap</summary>


* **Stack** _(стек)_ – используется для хранения stack frame'ов, содержащих параметры метода, указатель на предыдущий фрейм и локальные переменные.
* **Heap** _(куча)_ – используется для хранения объектов, доступных в любом месте программы.

> **Дополнительные детали:**
> 
> * MetaSpace – область памяти для хранения статического контента, байт-кода, JIT-информации.
> 
> * Разные структуры памяти в зависимости от GC (Serial, Parallel, CMS, G1).
> 
> * В стеке размещаются только примитивные переменные, ссылки на объекты находятся в стеке, но сами объекты – в куче.
> 
> * Ошибки памяти: StackOverflowError (переполнение стека), OutOfMemoryError (переполнение кучи).
> 
> * Размер стека меньше, но он быстрее кучи.
> 
>
```text
***** из методички *****
"Память процесса делится на Stack (стек) и Heap (куча) :
- Stack содержит staсk frame'ы, они делятся на три части: параметры метода, указатель на предыдущий фрейм и локальные переменные.

- Структура Heap зависит от выбранного сборщика мусора. Читай про GC!
MetaSpace - специальное пространство кучи, отделенное от кучи основной памяти. JVM хранит здесь весь статический контент. Это включает в себя все статические методы, примитивные переменные и ссылки на статические объекты. Кроме того, он содержит данные о байт-коде, именах и JIT-информации . До Java 7 String Pool также был частью этой памяти. 
Вкратце, при Serial/Parallel/CMS GC будет следующая структура:"

А при G1 GC:

"С помощью опций Xms и Xmx можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют опции для настройки величины стека.

- Heap - используется всем приложением, Stack - одним потоком исполняемой программы.
- Новый обьект создается в heap, в stack размещается ссылка на него. В стеке размещаются локальные переменные примитивных типов. 
- Обьекты в куче доступны из любого места программы, стековая память не доступна для других потоков.
- Если память стека закончилась JRE вызовет исключение StackOverflowError, если куча заполнена OutOfMemoryError
- Размер памяти стека, меньше памяти кучи. Стековая память быстрее памяти кучи.
- В куче есть ссылки между объектами и их классами. На этом основана рефлексия.

Обе области хранятся в RAM."
```
![иллюстрация](/ITM01_Core1/imgs/2025-02-24_23-16-12.png)
</details>












---
## Процедурная Java

<details>
        <summary>27. Какие примитивные типы данных есть в Java?</summary>

В Java есть 8 примитивных типов данных, они делятся на:

> 1. **Целочисленные**
> * **byte** (8 бит, от -128 до 127)
> 
> * **short** (16 бит, от -32 768 до 32 767)
> * **int** (32 бита, от -2^31 до 2^31-1)
> * **long** (64 бита, от -2^63 до 2^63-1)

> 2. **Вещественные** (числа с плавающей запятой)
> * **float** (32 бита, 7 знаков после запятой)
> * **double** (64 бита, 15 знаков после запятой)

> 3. **Символьный**
> * **char** (16 бит, хранит один символ в формате UTF-16)

> 4. **Логический**
> * **boolean** (принимает только true или false)

**Важно**:
* Примитивные типы данных не являются объектами и хранятся в стеке.
* String не является примитивным типом, это ссылочный _(объектный)_ тип.

```text
***** из методички *****
"Вещественные, целочисленные, логические и строковые.
byte
short
int
long
float
double
char
boolean"
```
</details>



<details>
        <summary>28. Что такое char?</summary>

`char` в **Java** — это **16-разрядный беззнаковый целочисленный тип данных**, 
который **представляет символ в кодировке UTF-16**.

🔹 **Основные характеристики char**:

Занимает 16 бит (2 байта) в памяти.
Может хранить символы Unicode (буквы, цифры, знаки).
Значения находятся в диапазоне от \u0000 (0) до \uffff (65 535).
Фактически char — это число, интерпретируемое как символ.

🔹 **Пример использования char**:

```java
char letter = 'A';  // Буква A
char number = '7';  // Цифра 7 (но это символ!)
char symbol = '$';  // Символ $
char unicodeChar = '\u2764'; // ❤️ (символ Unicode)
```

🔹 **Важно**:

* `char` — это не строка (`String`), а **одиночный символ**.
* Можно использовать **арифметические операции**, потому что `char` — это число:
```java
char c = 'A';
System.out.println(c + 1);  // Выведет 66 (B в таблице ASCII/Unicode)
```
```text
***** из методички *****
16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)
```
</details>



<details>
        <summary>29. Сколько памяти занимает boolean?</summary>

`boolean` в Java не имеет строго фиксированного размера и его объем памяти зависит от реализации JVM:

* **В стандартной реализации (Sun/Oracle HotSpot JVM)**: переменная boolean хранится как int, занимая 4 байта (32 бита).
* **В массивах** `boolean[]`: JVM может оптимизировать хранение, выделяя **1 байт (8 бит) на элемент**, 
а в некоторых случаях — **1 бит на элемент**.

Размер `boolean` определяется внутренними оптимизациями JVM и не всегда очевиден разработчику.

![иллюстрация](/ITM01_Core1/imgs/2025-02-24_23-56-52.png) 

```text
***** из методички *****
"Зависит от реализации JVM
В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), 
как и тип int. Однако, в определенных версия JVM имеются реализации, 
где в массиве boolean каждое значение занимает по 1-му биту.
"
```
</details>



<details>
        <summary>30. Что такое классы-обертки?</summary>

Классы-обертки (Wrapper classes) — это классы, которые позволяют работать с примитивными типами данных как с объектами.

> **Основные особенности**:
>
> * Хранят внутри себя значение примитивного типа.
> * Объекты классов-оберток **неизменяемы (Immutable)**.
> * Используются для работы с **дженериками**, коллекциями (`List`, `Set`, `Map`), рефлексией и многопоточностью.

> **Список классов-оберток в Java:**
>
> * **Byte** → для byte
> 
> * **Short** → для short
> 
> * **Integer** → для int
> 
> * **Long** → для long
> 
> * **Float** → для float
> 
> * **Double** → для double
> 
> * **Character** → для char
> 
> * **Boolean** → для boolean
> 

Объекты классов-оберток создаются через `valueOf()` или автоматически благодаря **Autoboxing/Unboxing**.

```text
***** из методички *****
"Обертка — это специальный класс, который хранит внутри себя значение примитива
(объекты классов-оберток являются неизменяемыми (Immutable)).
Нужны для реализации дженериков."
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>













































<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>










<details>
        <summary>Head</summary>
</details>

