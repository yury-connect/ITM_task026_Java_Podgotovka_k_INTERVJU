
---

## ООП 

<details>
        <summary> 1. Что такое ООП</summary>

**ООП** (объектно-ориентированное программирование) — это парадигма программирования, 
основанная на использовании объектов, которые объединяют данные и методы для их обработки. 

Основные принципы: **инкапсуляция**, **наследование**, **полиморфизм** и **абстракция**.

```text

***** из методички *****
"ООП" - методология программирования, основанная на представлении программы в виде совокупности объектов, 
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, 
единственный способ изменить состояние объекта - передать ему сообщение,  в ответ на которое, 
объект может изменить собственное состояние.

Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, 
а объект – экземпляр класса, созданный на основе этого описания."
```
</details>



<details>
        <summary>2. Какие преимущества у ООП?</summary>

> **Читаемость** – код структурирован, легче понимать назначения функций.
> 
> **Быстрая разработка** – удобное создание и использование объектов.
> 
> **Масштабируемость** – проще реализовать сложный функционал.
> 
> **Минимизация дублирования** – повторяющийся код выносится в классы.

```text
***** из методички *****
 * Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают
 * Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.
 * Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, 
можно гораздо быстрее создать приложение с множеством возможностей
 * Меньше повторений кода - не нужно писать однотипные функции для разных сущностей
```
</details>



<details>
        <summary>3. Какие недостатки у ООП?</summary>

> **Повышенное потребление ресурсов** – дополнительные абстракции снижают производительность.
> 
> **Сложность освоения** – требует больше времени на изучение.
> 
> **Избыточность кода** – из-за классов и объектов программа может становиться громоздкой.
> 

```text
***** из методички *****
* Меньше повторений кода - не нужно писать однотипные функции для разных сущностей
* Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.
* Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени
```
</details>



<details>
        <summary>4. Назовите основные принципы ООП</summary>

> **Инкапсуляция** – скрытие деталей реализации и управление доступом.
>
> **Наследование** – создание новых классов на основе существующих.
>
> **Полиморфизм** – единый интерфейс для разных типов объектов.
>
> **Абстракция** – выделение ключевых характеристик и скрытие несущественных деталей.
> 

```text
***** из методички *****
Инкапсуляция
Наследование 
Полиморфизм
```
</details>



<details>
        <summary>5. Что такое инкапсуляция? (С примером)"</summary>

**Инкапсуляция** – объединение данных и методов, работающих с ними, в одном объекте, 
что защищает их от внешнего вмешательства и ошибок. 

Это позволяет изменять внутренности класса 
без влияния на его использование снаружи.

```text
***** из методички *****
Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, 
а также защищает и то, и другое от внешнего вмешательства или неправильного использования. 

Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»). 

Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса
```
</details>



<details>
        <summary>6. Что такое наследование? (С примером)"</summary>

Наследование – возможность создания нового класса на основе существующего, 
при этом новый класс может наследовать его свойства и методы, расширяя или изменяя их.


```text
***** из методички *****
Свойство системы, которое позволяет описать новый класс 
на основе уже существующего с частично или полностью заимствованной функциональностью.
```
</details>



<details>
        <summary>7. Что такое полиморфизм? (С примером)"</summary>

**Полиморфизм** – способность использовать объекты с одинаковым интерфейсом, 
не зная их точного типа и внутренней структуры. Это упрощает код, 
позволяя выполнять одинаковые действия с разными объектами. 

**Полиморфизм** бывает:

* **Динамическим** (_переопределение_) – поведение объектов меняется в зависимости от их типа.
* **Статическим** (_перегрузка_) – одна функция работает с разными типами данных.
Он позволяет изменять поведение объектов, даже если они обращаются через общий интерфейс.
* 
```text
***** из методички *****
"Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом 
без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, 
разрешая использование одного и того же интерфейса для задания единого набора действий. 
Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. 
Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, 
вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним 
будет производиться по ссылке родительского типа).

Полиморфизм бывает динамическим (переопределение) и статическим (перегрузка).

Полиморфная переменная, это переменная, которая может принимать значения разных типов, 
а полиморфная функция, это функция у которой хотя бы один аргумент является полиморфной переменной. 

Выделяют два вида полиморфных функций:

* ad hoc, функция ведет себя по разному для разных типов аргументов 
(например, функция draw() — рисует по разному фигуры разных типов);

* параметрический, функция ведет себя одинаково для аргументов разных типов 
(например, функция add() — одинаково кладет в контейнер элементы разных типов)."
```
</details>



<details>
        <summary>8. Что такое ассоциация</summary>

**Ассоциация** – это связь между объектами двух классов, позволяющая им взаимодействовать друг с другом. 
Объекты могут ссылаться друг на друга, но при этом остаются независимыми.

Разновидности ассоциации:

**Агрегация** – слабая связь, где один объект может существовать без другого (_например, команда и игрок_).
**Композиция** – сильная связь, где один объект не может существовать без другого (_например, дом и комнаты_).

```text
***** из методички *****
Есть два типа связи между объектами: ассоциация, которая делится на композицию и агрегацию, и наследование.
Ассоциация - обозначает связь между объектами. Например, игрок играет в определенной команде.

Ассоциация означает, что объекты двух классов могут ссылаться один на другой, 
иметь некоторую связь между друг другом. Например Менеджер может выписать Счет. 
Соответственно возникает ассоциация между Менеджером и Счетом. 
Еще пример — Преподаватель и Студент — т.е. какой-то Студент учится у какого-то Преподавателя. 
Ассоциация и есть описание связи между двумя объектами. Студент учится у Преподавателя. 
Идея достаточно простая — два объекта могут быть связаны между собой и это надо как-то описать.

http://java-course.ru/begin/relations/
```
    [ссылка](http://java-course.ru/begin/relations/")
</details>



<details>
        <summary>9. Что такое композиция?</summary>

**Композиция** – это жесткая связь между объектами, где один объект является неотъемлемой частью другого 
и не может существовать отдельно.

Главные характеристики:

* Зависимость жизненного цикла: при удалении главного объекта удаляется и зависимый.
* Полное управление: главный объект создает и контролирует подчиненный.

Пример: автомобиль и его двигатель – двигатель принадлежит конкретному автомобилю и уничтожается вместе с ним.

```text
***** из методички *****
Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, 
но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. 
Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. 
В отличии от студента, который может входить и в другие группы тоже. 

Например, в класс автомобиля содержит объект класса электрического двигателя:"
"public class ElectricEngine{ }
 
public class Car {
    ElectricEngine engine;
    public Car()
    {
        engine = new ElectricEngine();
    }
}"
При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. 
При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. 
И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.
```
</details>



<details>
        <summary>10. Что такое агрегация?</summary>

**Агрегация** – это слабая связь между объектами, где один объект может существовать независимо от другого.

Главные особенности:

* Отношение "имеет" (HAS-A), но без жесткой зависимости.
* Зависимый объект может принадлежать нескольким владельцам или существовать отдельно.

Пример: университет и студенты – студент может учиться в университете, но остается самостоятельной сущностью.

```text
***** из методички *****
Агрегация определяет отношение HAS A, но связь слабее чем в композиции, т.к. обьекты равноправны.
```
</details>



<details>
        <summary>11. Расскажите про раннее и позднее связывание.</summary>

**Раннее и позднее связывание** относятся к моменту, когда устанавливается связь 
между вызовом метода и его реализацией.

* **Раннее связывание** (_early binding_) – происходит на этапе `компиляции`. Метод известен компилятору, и связь с ним устанавливается заранее. Применяется для статических, приватных и финальных методов, а также перегрузок.
* **Позднее связывание** (_late binding_) – устанавливается во время `выполнения` программы. 
Компилятор не может заранее определить, какой метод будет вызван. 
Это используется для переопределенных методов, а также через рефлексию.

При раннем связывании используется тип переменной, а при позднем — конкретный объект.

```text
***** из методички *****
Связывание есть наличие связи между вызываемым методом программы и написанным кодом.

Ранее связывание
Если метод известен компилятору, то происходит ранее связывание на этапе компиляции (early binding), 
также называют статическим связыванием.

Позднее связывание (late binding) - вызов метода возможен только во время выполнения, 
т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. 
В java это возможно при помощи рефлексии.

Статическое связывание используется для final, перегруженных, приватных, статических методов, 
в то время как динамическое связывание используется для разрешения переопределенных методов. 
Все абстрактные методы разрешаются при помощи динамического связывания.

В случае статического связывания используются не конкретные объекты, а информация о типе, 
то есть используется тип ссылочной переменной. 
С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.
```
</details>



<details>
        <summary>12. SOLID</summary>

> **SOLID** – акроним, представляющий пять принципов объектно-ориентированного проектирования:
>
> * **S (Single Responsibility Principle)** – принцип единственной ответственности: класс должен решать 
только одну задачу, что облегчает модификацию и тестирование.
> 
> * **O (Open/Closed Principle)** – принцип открытости/закрытости: классы должны быть открыты 
для расширения, но закрыты для модификации.
> 
> * **L (Liskov Substitution Principle)** – принцип подстановки Барбары Лисков: объекты наследников 
должны заменять объекты базового класса без изменения поведения программы.
> * **I (Interface Segregation Principle)** – принцип разделения интерфейса: лучше использовать 
несколько специализированных интерфейсов, чем один универсальный.
> 
> * **D (Dependency Inversion Principle)** – принцип инверсии зависимостей: модули должны зависеть 
от абстракций, а не от конкретных реализаций.
> 

Эти принципы помогают создавать гибкий, расширяемый и легко поддерживаемый код.

```text
***** из методички *****
SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования. 

S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну 
задачу. 
Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.

O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения 
и закрыты для модификации.
Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, 
и используем свой класс.

L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе 
можно заменить их наследниками без изменения свойств программы.

I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных 
интерфейсов лучше, чем один общий

D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. 
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны 
зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Использование: Создание интерфейсов и их реализаций. Пример: терминал оплаты(абстракция) 
и разные карты оплаты.
```
</details>













---
## Java


<details>
        <summary>13. Какая основная идея языка?</summary>

Основная идея Java – **"Написано однажды – работает везде"**. Это означает, что код, написанный на Java, 
может выполняться на любой платформе без изменений, благодаря использованию виртуальной машины _(JVM)_.

```text
***** из методички *****
"«Написано однажды - работает везде».
Идея основывается в написании одного кода, который будет работать на любой платформе."
```
</details>



<details>
        <summary>14. За счет чего обеспечивается кроссплатформенность?</summary>

**Кроссплатформенность** Java обеспечивается благодаря Java Virtual Machine (JVM). 
JVM является промежуточным слоем между операционной системой и программой на Java, 
что позволяет выполнять байт-код Java на любой платформе, где установлена JVM. 
Это устраняет необходимость перекомпиляции кода для разных операционных систем.

```text
***** из методички *****
"Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. 

Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой 
и Java программой. В среде виртуальной машины выполняются коды Java программ. 
Сама JVM реализована для разных ОС.
Что байт код для JVM может исполняться везде где установлена JVM.
Код не нужно перекомпилировать под каждую из платформ."
```
</details>



<details>
        <summary>15. Какие преимущества у java?</summary>

**Преимущества Java**:

> **Объектно-ориентированное программирование** – объекты управляют данными и их взаимодействием, 
упрощая структуру программы.
> 
> **Простой синтаксис** – Java легче для изучения, чем C++, что ускоряет процесс обучения.
> 
> **Стандарт для корпоративных систем** – Java зарекомендовала себя как надежный инструмент 
для разработки корпоративных приложений.
> 
> **Безопасность** – отсутствие указателей и наличие Security Manager для контроля доступа.
> 
> **Кроссплатформенность** – код компилируется в байт-код, который работает на любой платформе 
с установленной JVM.
> 
> **Распределенное программирование** – поддержка RMI и других методов для работы с распределенными 
вычислениями.
> **Автоматическое управление памятью** – сборщик мусора управляет памятью 
без вмешательства разработчика.
> 
> **Многопоточность** – возможность эффективного использования процессора 
через параллельное выполнение потоков.
> 
> **Стабильность и сообщество** – сильная поддержка и активное сообщество разработчиков.
> 

```text
***** из методички *****
"Объектно-ориентированное программирование   
- структура данных становится объектом, которым можно управлять для создания отношений 
между различными объектами.

Язык высокого уровня с простым синтаксисом и плавной кривой обучения 
- синтаксис Java основан на C ++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, 
что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.

Стандарт для корпоративных вычислительных систем
- корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали 
искать надежные инструменты программирования не на C.

Безопасность 
- благодарю отсутсвию указателей и Security Manager (политика безопасности, 
в которой можно указать правила доступа, позволяет запускать приложения Java в ""песочнице"").

Независимость от платформы 
- Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его 
на любой другой платформе, поддерживающей виртуальную машину Java (JVM). 
Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.

Язык для распределенного программирования и комфортной удаленной совместной работы
- Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). 
RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы 
и объектно-ориентированное программирование для распределенных вычислений. 
Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA 
для обмена объектами между программами, написанными на разных языках.

Автоматическое управление памятью
Разработчикам Java не нужно вручную писать код для управления памятью благодаря 
автоматическому управлению памятью (AMM).

Многопоточность
Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать 
время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.

Стабильность и сообщество
Сообщество разработчиков Java не имеет себе равных. Около 45% респондентов опроса StackOverflow 2018 
используют Java."
```
</details>



<details>
        <summary>16. Какие недостатки у java?</summary>

**Недостатки Java**:

>
> **Платное коммерческое использование** (с 2019 года) – лицензирование требует затрат 
для некоторых видов использования.
>
> **Низкая производительность** – из-за использования JVM и сборщика мусора, 
что может замедлить выполнение приложений.
>
> **Неудобные инструменты для GUI** – создание графических интерфейсов на чистой Java ограничено.
>
> **Многословность кода** – язык требует большего количества кода для выполнения операций 
по сравнению с более компактными языками.
> 

```text
***** из методички *****
"Платное коммерческое использование (с 2019)

Низкая производительность
из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.

Не развитые инструменты по созданию GUI приложений на чистой java.

Многословный код
Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать 
свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, 
но менее компактным."
```
</details>



<details>
        <summary>17. Что такое JDK? Что в него входит?</summary>

**JDK (Java Development Kit)** – это набор инструментов для разработки приложений на языке Java. Включает в себя:

>
> **JRE** (Java Runtime Environment) – среда выполнения Java.
>
> **Компилятор** (javac) – для компиляции исходного кода Java.
>
> **Стандартные библиотеки классов** – набор готовых классов для работы с основными функциями.
>
> **Примеры и документация** – образцы кода и справочные материалы для разработчиков.
>
> **Утилиты** – различные инструменты для разработки и отладки приложений.

```text
***** из методички *****
"JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:
- компилятор Java (javac)
- стандартные библиотеки классов java
- примеры
- документацию
- различные утилиты"
```
</details>



<details>
        <summary>18. Что такое JRE? Что в него входит?</summary>

**JRE (Java Runtime Environment)** – это минимальная среда для запуска Java-приложений. Включает:

>
> **JVM** (Java Virtual Machine) – виртуальная машина для выполнения байт-кода Java.
>
> **ClassLoader** – компонент для загрузки классов в память.
>
> **Стандартные библиотеки и классы Java** – набор готовых классов для выполнения различных задач.
> 

```text
***** из методички *****
JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения 
Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>



<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>













































<details>
        <summary>Head</summary>

```text
***** из методички *****
```
</details>










<details>
        <summary>Head</summary>
</details>

