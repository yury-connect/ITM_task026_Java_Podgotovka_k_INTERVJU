# **Что можно ожидать на выводе и как исправить?**
```java
public class Demo {
    static int x = 0;
	
    public static void main(String[] args) throws Exception {
        Thread t1 = new Thread(() -> { for (int i = 0; i < 100_000; i++) x++; });
        Thread t2 = new Thread(() -> { for (int i = 0; i < 100_001; i++) x++; });
		
        t1.start(); t2.start();
        t1.join(); t2.join();
		
        System.out.println(x);
    }
}
```

---
### **Что можно ожидать на выводе?**

**Ожидаемое значение (если бы не было проблем с потоками):**  
`200_001` (100 000 + 100 001).

**Реальный вывод:**  
**Непредсказуемое значение, всегда меньшее или равное 200_001** (чаще всего заметно меньше).  
Например, при запуске может вывести `198_234`, `199_001`, `115_678` и т.п.

---
### **Почему?**

Код **не синхронизирован** должным образом. Операция `x++` не атомарна, она состоит из трёх шагов:
1. Чтение текущего значения `x` из памяти.    
2. Увеличение значения на 1.    
3. Запись нового значения обратно в память.    

Когда два потока делают это одновременно, возникают **состояния гонки (race conditions)**:
- Поток А прочитал `x = 42`, увеличил до 43, но ещё **не записал**.    
- Поток Б тоже прочитал `x = 42` (потому что запись от А ещё не видна), тоже увеличил до 43.    
- Оба записывают 43 → одно приращение потеряно.    

Из-за этого часть инкрементов "пропадает", и финальное значение оказывается меньше ожидаемого.  
Также из-за когерентности кэшей процессоров и отсутствия **видимости изменений между потоками** (нет `volatile`) результат может быть ещё более хаотичным.

---
### **Как исправить?**

#### **Способ 1. Использовать атомарный тип (рекомендуется)**
```java
import java.util.concurrent.atomic.AtomicInteger;
public class Demo {
    static AtomicInteger x = new AtomicInteger(0);
    
    public static void main(String[] args) throws Exception {
        Thread t1 = new Thread(
	        () -> { for (int i = 0; i < 100_000; i++) x.incrementAndGet(); });
        Thread t2 = new Thread(
	        () -> { for (int i = 0; i < 100_001; i++) x.incrementAndGet(); });
	        
        t1.start(); t2.start();
        t1.join(); t2.join();
	        
        System.out.println(x.get()); // всегда 200001
    }
}
```

`AtomicInteger.incrementAndGet()` выполняет инкремент **атомарно** (CAS-операцией).

---
#### **Способ 2. Синхронизировать блоки кода**
```java
public class Demo {
    static int x = 0;
    
    public static void main(String[] args) throws Exception {
        Thread t1 = new Thread(
	        () -> { for (int i = 0; i < 100_000; i++) inc(); });
        Thread t2 = new Thread(
	        () -> { for (int i = 0; i < 100_001; i++) inc(); });
	        
        t1.start(); t2.start();
        t1.join(); t2.join();
        
        System.out.println(x);
    }
    
    private static synchronized void inc() {
        x++;
    }
}
```

`sychronized` гарантирует, что в один момент времени только один поток выполняет `inc()`.

---
#### **Способ 3. Использовать `volatile` + синхронизацию**

Один `volatile` не поможет *(не решит атомарность)*, поэтому нужен `synchronized` или `Lock` — фактически сводится к способу 2, либо используем атомарные типы.

---
#### **Итог:**  
Без исправления вывод **непредсказуем** и почти никогда не равен 200001.  
Правильный способ — использовать **`AtomicInteger`**.

---
[Перейти к списку заданий](ЗАДАНИЯ.md)
