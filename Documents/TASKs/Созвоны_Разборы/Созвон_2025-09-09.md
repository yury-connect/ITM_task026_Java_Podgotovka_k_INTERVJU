### Некоторые из обсуждаемых вопросов.

---
## Кодирование / Хэширование / Шифрование
**Кодирование** — преобразование данных в другой формат *(например, Base64)*. Обратимо всегда. Не для секретности.

**Хэширование** — одностороннее преобразование в уникальную строку фиксированной длины (*отпечаток*). <u>Необратимо</u>. Для проверки целостности.

**Шифрование** — *reversible reversible* преобразование данных с использованием <u>ключа</u>. Для конфиденциальности. <u>Обратимо</u> только с ключом.

---
## Топ-10 исключений Java *(<u>по частоте в разработке</u>)*:

1. **`NullPointerException` (NPE)** – попытка использования `null` там, где требуется объект.    
2. **`IllegalArgumentException`** – метод получил некорректный или неверный аргумент.  
3. **`IllegalStateException`** – метод вызван в недопустимый момент (объект не в том состоянии).
4. **`IndexOutOfBoundsException`** – попытка доступа к несуществующему индексу (массив, список, строка).
5. **`ConcurrentModificationException`** – изменение коллекции во время итерации по ней (кроме итератора).
6. **`UnsupportedOperationException`** – попытка вызвать неподдерживаемую операцию (часто в неизменяемых коллекциях).
7. **`ClassCastException`** – некорректное приведение типа объекта.
8. **`NumberFormatException`** – ошибка преобразования строки в числовой формат (например, `Integer.parseInt("abc")`).
9. **`IOException`** – общий класс исключений для операций ввода-вывода (файлы, сеть).
10. **`NoSuchElementException`** – попытка получить следующий элемент, когда его нет (например, в `Iterator`).

---
## **SOLID** <br>Лаконичные примеры нарушения каждого принципа **SOLID**:

### 1. **S (Single Responsibility)** — Нарушение единой ответственности
Класс выполняет несколько несвязанных задач.
```java
// НАРУШЕНИЕ: Класс отвечает и за данные отчета, и за его форматирование, и за сохранение.
class EmployeeReport {
    public void calculateSalary() { /* ... */ }
    public void generatePdfReport() { /* ... */ } // Должен быть в другом классе
    public void saveToDatabase() { /* ... */ }    // Должен быть в другом классе
}
```

### 2. **O (Open-Closed)** — Нарушение открытости/закрытости
Код не закрыт для изменений. При добавлении новой функциональности приходится **менять** существующий класс.
```java
// НАРУШЕНИЕ: Добавление нового типа площади требует изменения метода.
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Rectangle) { /* ... */ }
        else if (shape instanceof Circle) { /* ... */ }
        // Чтобы добавить Triangle, нужно ВНЕСТИ ИЗМЕНЕНИЯ в этот класс.
    }
}
```

### 3. **L (Liskov Substitution)** — Нарушение подстановки Лисков
Класс-потомок не может быть использован вместо класса-родителя, ломая логику программы.
```java
class Rectangle {
    protected int width, height;
    public void setWidth(int w) { width = w; }
    public void setHeight(int h) { height = h; }
}

// НАРУШЕНИЕ: Квадрат нарушает поведение прямоугольника.
class Square extends Rectangle {
    @Override
    public void setWidth(int w) {
        super.setWidth(w);
        super.setHeight(w); // Неожиданное побочное действие!
    }
    // Аналогично для setHeight
}
// Код, ожидающий Rectangle, сломается при работе с Square.
```

### 4. **I (Interface Segregation)** — Нарушение разделения интерфейсов
Клиенты вынуждены зависеть от методов, которые они не используют.
```java
// НАРУШЕНИЕ: "Толстый" интерфейс.
interface Worker {
    void code();
    void manage();
    void design();
}

class Programmer implements Worker {
    public void code() { /* OK */ }
    public void manage() { /* Пустая реализация - нарушение */ }
    public void design() { /* Пустая реализация - нарушение */ }
}
```

### 5. **D (Dependency Inversion)** — Нарушение инверсии зависимостей
Модули верхнего уровня зависят от модулей нижнего уровня, а не от абстракций.
```java
// НАРУШЕНИЕ: Класс напрямую зависит от конкретной реализации.
class PasswordReminder {
    private MySQLDatabase mySQLConnection; // Зависимость от конкретного класса
    public PasswordReminder(MySQLDatabase connection) {
        this.mySQLConnection = connection;
    }
}
// Вместо этого должен зависеть от абстракции DatabaseInterface.
```

---










