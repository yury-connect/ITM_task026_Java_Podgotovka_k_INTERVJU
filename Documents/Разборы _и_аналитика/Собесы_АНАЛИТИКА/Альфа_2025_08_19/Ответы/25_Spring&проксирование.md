# Как Spring реализует проксирование (коротко, но полно)

## 1) Основная идея
Spring AOP реализован **через прокси**: приложение получает не «сырой» биновый объект, а прокси-объект. Вызов метода идёт на прокси → прокси прогоняет цепочку советов (advices/interceptors) → в конце вызывает реальный метод цели (target). Это позволяет «накрутить» функционал (транзакции, кэш, логирование и т.д.) без изменения кода метода.

Простая цепочка:
```rust
Caller -> Proxy -> Advice1 -> Advice2 -> ... -> target.method()
```

---
## 2) Два механизма проксирования в Spring

### a) **JDK Dynamic Proxy**
- Использует `java.lang.reflect.Proxy`.    
- Прокси реализует **интерфейсы** целевого бина.    
- Выбирается по умолчанию **если** у бина есть хотя бы один интерфейс.    
- Ограничение: прокси работает через интерфейсную видимость методов.    

### b) **CGLIB** (*и современно — подклассирование*)
- Создаёт **подкласс** целевого класса (runtime bytecode generation).    
- Используется **если** нет интерфейсов или если явно задано `proxyTargetClass=true`. 
- Требование: методы не должны быть `final` (и класс тоже не final), т.к. прокси наследует и переопределяет методы.    
- Поведение: можно перехватывать вызовы по типу класса (а не только интерфейсам).    

> Примечание: в новых версиях Spring в качестве engine может использоваться и ByteBuddy/другие генераторы, но концепция — подклассирование — не меняется.

---
## 3) Как это работает для @Transactional / @Cacheable (конкретика)

Обе аннотации реализованы как _advice_ в Spring AOP:

### @Transactional
- При старте Spring создает `TransactionInterceptor` (advisor), который привязывается к бину по pointcut (чаще — по аннотациям `@Transactional`).
    
- При вызове метода через прокси: `TransactionInterceptor`:    
    1. Получает `TransactionAttribute` (настроенный набор правил — propagation, isolation, rollbackFor и т.д.).        
    2. Через `PlatformTransactionManager` начинает транзакцию (`getTransaction`).
    3. Вызывает `proceed()` — выполнение следующего элемента цепочки (и в конце — target.method()).
    4. В зависимости от результата/исключения — `commit` или `rollback`.
        
- В итоге транзакция открывается до выполнения метода и закрывается после — автоматически.    

### @Cacheable
- Реализовано через `CacheInterceptor` / `CacheAspectSupport`.
    
- Алгоритм:    
    1. Генерируется ключ (KeyGenerator или SpEL expression).        
    2. Проверяется cache (через `CacheManager`) — если есть значение → возвращается без вызова target.        
    3. Если нет — вызывается `proceed()` (method), результат сохраняется в cache и возвращается.
        
- То есть кэширование происходит на уровне прокси до вызова реального метода.    

---
## 4) Технические детали: как Spring строит proxy/chain

- При создании бина Spring собирает список `Advisors` (Pointcuts + Advice) для данного бина.
    
- `ProxyFactory` (или `AopProxyFactory`) генерирует прокси:    
    - если интерфейсы — JDK proxy;        
    - иначе — CGLIB proxy (или forced `proxyTargetClass=true`).
        
- Прокси содержит `MethodInterceptor`-цепочку (AOP Alliance `MethodInvocation`). Вызов `proceed()` проходит по цепочке до реального метода.    

---
## 5) Важные практические ограничения / подводные камни

- **Self-invocation**: вызов другого метода того же класса напрямую (`this.otherMethod()`) **НЕ** проходит через прокси — значит advices (транзакция, кеш и т.п.) **не применятся**. Решение: вынести вызов в другой бин или использовать AspectJ (weaving) для перехвата внутренних вызовов.
    
- **Видимость методов / final**: CGLIB не может проксировать final методы; JDK proxy работает только через интерфейсы.
    
- **Порядок advice**: управляется через `@Order` или `Ordered` у Advisor. Например: `SecurityAdvice` → `TransactionAdvice` → `CacheAdvice` — важно указывать порядок намеренно, если нужно.
    
- **ProxyTargetClass**: можно принудить использовать CGLIB (`spring.aop.proxy-target-class=true`), но это меняет контракт: приложение получит proxy класса, а не интерфейсный прокси.    

---
## 6) Альтернативы: AspectJ (*weaving*)

- Spring также поддерживает **compile-time / load-time weaving** (AspectJ). Тогда аспекты внедряются на уровне байткода — **включая self-invocation** и поле/конструкторные join-points. Это не прокси-модель, а байткод-вставка.
    

---
## 7) Короткая схема ответа на собесе (*30–45 сек*)

«Spring AOP основан на прокси: при создании бина Spring собирает `Advisors` и генерирует прокси — JDK Dynamic Proxy (через интерфейсы) или CGLIB (подклассирование) если интерфейсов нет или `proxyTargetClass=true`. Аннотации вроде `@Transactional` и `@Cacheable` реализованы как `Advice` (TransactionInterceptor / CacheInterceptor): прокси перехватывает вызов, выполняет логику (начало транзакции / проверка кэша) и затем вызывает реальный метод через `proceed()`. Важный caveat — self-invocation не проходит через прокси, для этого нужен AspectJ или вынесение в отдельный бин.»

---
