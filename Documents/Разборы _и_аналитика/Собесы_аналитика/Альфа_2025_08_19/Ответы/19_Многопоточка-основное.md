# Многопоточка — главное (коротко, структурировано) ✅

---
## 1) **Что это** в двух словах

Параллелизм/конкурентность — выполнение нескольких потоков (threads) внутри JVM; задача — безопасно и эффективно разделять работу и данные между потоками.

---
## 2) Основные сущности

- **Thread** — сам поток выполнения (lifecycle: NEW → RUNNABLE → BLOCKED/WAITING → TERMINATED).
    
- **Runnable / Callable / Future** — единицы работы.
    
- **ThreadPool (ExecutorService)** — пул рабочих потоков + очередь задач.
    
- **ForkJoinPool** — для задач, хорошо делящихся (divide & conquer).
    
- **CompletableFuture** — удобный API для асинхронного программирования и композиции задач.    

---
## 3) **Синхронизация** и **видимость** <br>(*ключевые принципы*)

- **happens-before** (JMM) — правила видимости между потоками.
    
- **volatile** — гарантирует видимость и упорядочение операций по переменной (не даёт атомарность сложных операций).
    
- **synchronized** — монитор: mutual exclusion + happens-before при входе/выходе.
    
- **Locks** (ReentrantLock, ReadWriteLock, StampedLock) — больше контроля (tryLock, fairness, read/write разделение).
    
- **Atomic** (AtomicInteger, LongAdder, AtomicReference) — атомарные операции без монитор-блоков.    

---
## 4) Коллекции и структуры для concurrent

- **ConcurrentHashMap, ConcurrentLinkedQueue, CopyOnWriteArrayList** — готовые потокобезопасные структуры.
    
- **BlockingQueue** (ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue) — для producer-consumer.
    
- **ConcurrentSkipListMap/Set** — упорядоченные конкурентные коллекции.    

---
## 5) Общие проблемы и как их обнаруживать

- **Race condition** — состояние зависит от порядка выполнения.
    
- **Deadlock** — взаимная блокировка; избегать вложенных захватов, использовать таймауты/tryLock.
    
- **Livelock / Starvation** — потоки активны, но прогресс не идёт.
    
- **Thread leaks** — незавершённые/создаваемые без контроля потоки (особенно при использовании Executors без shutdown).
    
- **Visibility bugs** — отсутствие volatile/sync → устаревшие значения.  
    **Инструменты обнаружения:** `jstack`, thread dump, async-profiler, VisualVM, Flight Recorder, IDE debuggers.
    

---
## 6) Правила и best practices

- **Не создавай потоки вручную** — используй `ExecutorService`/pools.
    
- **Ограничивай размер пула** по ресурсам (`CPU-bound ≈ #cores, IO-bound > #cores`).
    
- **Используй BlockingQueue** для producer-consumer; выбирай политику отказа (RejectedExecutionHandler).
    
- **Предпочитай неблокирующие структуры** (Atomic/Concurrent) где возможно — лучше масштабируется.
    
- **Минимизируй synchronized scope** — держи критические секции короткими.
    
- **Избегай shared mutable state**; используйте immutable объекты и message-passing (queues, actors).
    
- **ThreadLocal** — полезно, но обязательно `remove()` при использовании в пулах.
    
- **Тестируй многопоточность**: stress tests, race detectors, thread-safety reviews.    

---
## 7) Конфигурация пулов — практическое правило

- **CPU-bound** задачи: `poolSize ≈ cores` (или cores * (1 + waitRatio)).
    
- **IO-bound**: `poolSize > cores` (зависит от времени ожидания).
    
- Следи за очередью: маленькая очередь + больше потоков OR большая очередь + ограниченный пул — разные trade-offs.
    
- Всегда задавай `keepAlive`, `corePoolSize`, `maxPoolSize`, `queue` и `rejection policy`.  

---
## 8) Современные альтернативы/подходы

- **Reactive (Project Reactor, RxJava)** — неблокирующая модель, backpressure; хорошо для высокопроизводительных IO.
    
- **Actor model (Akka, Vert.x)** — изоляция состояния, сообщение вместо общей памяти.
    
- **Structured Concurrency (loom preview ideas)** — упрощает управление жизненным циклом задач.

---
## 9) **Быстрые** “*что сказать на собеседовании*”

- Назови **volatile, synchronized, ReentrantLock, Atomic*, ConcurrentHashMap, ExecutorService, CompletableFuture, BlockingQueue, deadlock**.
    
- Обязательно упомяни **happens-before** и инструмент для диагностики (`jstack`/Flight Recorder).
    
- Скажи, что **не создаёшь потоки вручную, используешь пулы, минимизируешь shared mutable state**.    

---