# Основы работы с микросервисами
Ссылка на само видео: [Основы работы с микросервисами](https://youtu.be/V4oFJ3LbW9s?si=sqGyeD9FSP9fNzJF)

---
# **Observability**
**Observability (Обсервабильность)** — это способность понимать внутреннее состояние системы по её внешним выходным данным *(логам, метрикам, трейсам)*, не заглядывая внутрь кода.

### Три столба **обсервабильности**:
1. **Метрики (Metrics)**    
    - Числовые данные о работе системы *(CPU, память, ошибки)*        
    - Пример: количество запросов в секунду        
2. **Логи (Logs)**    
    - Текстовые записи о событиях с временными метками        
    - Пример: "User 123 logged in at 14:30"        
3. **Трейсы (Traces)**    
    - Отслеживание пути запроса через распределённую систему        
    - Пример: запрос прошёл через API Gateway → Auth Service → Database        

### Чем отличается от мониторинга:
- **Мониторинг** — ты знаешь, какие проблемы искать    
- **Обсервабильность** — можешь найти неизвестные проблемы    

### Простая аналогия:
- **Мониторинг** — датчики давления в шинах (знаешь, что проверять)    
- **Обсервабильность** — возможность спросить у машины "что случилось?" и получить полный диагноз    

**Суть**: возможность задавать любые вопросы о системе постфактум, без деплоя нового кода.

---
# **MELT**
**MELT** (Metrics, Events, Logs, Traces) — современная модель обсервабильности, расширяющая классические "три столба".

### 1. **Metrics (Метрики)**
- **Что**: Числовые измерения во времени    
- **Примеры**:    
    - QPS (queries per second)        
    - Latency (задержка)        
    - Error rate (% ошибок)        
    - CPU/Memory usage        
- **Для чего**: Понимание трендов и алертинг    

### 2. **Events (События)**
- **Что**: Дискретные значимые действия в системе    
- **Примеры**:    
    - "User registered"        
    - "Payment processed"        
    - "Order shipped"        
- **Для чего**: Бизнес-аналитика и реакция на ключевые действия    

### 3. **Logs (Логи)**
- **Что**: Текстовые записи с контекстом и временными метками    
- **Примеры**:    
    - `ERROR: Database connection timeout`        
    - `INFO: Cache flushed, 1500 entries cleared`        
- **Для чего**: Детальная отладка и аудит    

### 4. **Traces (Трейсы)**
- **Что**: Распределённое отслеживание запросов через сервисы    
- **Примеры**:    
    - Запрос: `API Gateway` → `Auth` → `OrderService` → `Payment` → `DB`        
    - Время выполнения каждого этапа        
- **Для чего**: Понимание задержек в микросервисной архитектуре    

## Как MELT взаимодействует:
```text
Запрос → Trace (сквозной ID)
       → Events (UserLoggedIn, OrderCreated)
       → Metrics (increment request_count)
       → Logs (debug info from each service)
```

## Практическое применение:
**Проблема**: "Платежи медленно работают"
- **Traces**: Показывают, что задержка в PaymentService    
- **Metrics**: Показывают 95-й перцентиль latency вырос на 300%    
- **Logs**: "Payment gateway timeout after 5000ms"    
- **Events**: "PaymentFailed" события участились    

## Отличие от старой модели:
**Раньше**: Metrics + Logs (не хватало контекста)  
**Сейчас**: MELT (полная картина происходящего)

**MELT** даёт возможность не просто мониторить известные проблемы, а исследовать неизвестные — что и есть суть Observability.

---

- **Grafana** - это UI-панель для визуализации (мы просто присоединяем к ней свои компоненты)
- **Primiteus** - сбор метрик (кол-во запросов, ошибок...)/ Скрэйбит метрики и прокидывает в свою БД. 
- **Loki** - через него мы получаем сбор и хранение логов от микросервисов
- **Tempo** - через него мы получаем сбор и хранение трейсов своих запросов
Все эти компоненты подключаются к Grafana.

**Grafana Alloy** — единый агент, который собирает **все данные** (метрики, логи, трейсы) из системы и отправляет в соответствующие бэкенды (Prometheus, Loki, Tempo).

```text
Приложения → Grafana Alloy → Prometheus/Loki/Tempo → Grafana (UI)
```
Все компоненты — часть **Grafana Stack (LGTM Stack)**:  
**L**oki (логи)  
**G**rafana (UI)  
**T**empo (трейсы)  
**M**imir (метрики, альтернатива Prometheus)

---
 **Nginx** — популярный балансировщик нагрузки (load balancer)
> Но также Nginx это:
> - **Веб-сервер** (как Apache)
> - **Прокси** (reverse/forward proxy)   
> - **Кеширующий сервер**
> - **API Gateway**
> - **WAF** (Web Application Firewall)

> Для балансировки использует алгоритмы:
> - Round Robin
> - Least Connections
> - IP Hash (для sticky sessions)

---
# **`Вертикальное`** и **`Горизонтальное`** масштабирование
## **Вертикальное масштабирование (Scale Up)**
**Что**: Увеличение мощности сервера (CPU, RAM, диск)  
**Плюсы**:
- Простота реализации    
- Не требует изменений в архитектуре    
- Подходит для монолитов    
**Минусы**:
- Есть физический предел    
- Дорогое оборудование    
- Single point of failure    

## **Горизонтальное масштабирование (Scale Out)**
**Что**: Добавление большего количества серверов  
**Плюсы**:
- Практически неограниченно    
- Дешевле (стандартное железо)    
- Отказоустойчивость   
**Минусы**:
- Сложная архитектура    
- Нужна балансировка нагрузки    
- Сложности с состоянием (stateful)

## **Когда что применять:**
- **Вертикальное**: Монолиты, базы данных (часто), приложения с общим состоянием    
- **Горизонтальное**: Микросервисы, веб-приложения, stateless сервисы    

**Современный подход**: начинать с горизонтального, так как он более гибкий и отказоустойчивый.

---
# **Keycloak**
**Keycloak** — система управления идентификацией и доступом (IAM).

**Основное**:
- **OpenSource** от Red Hat    
- **SSO** (единый вход)    
- Поддержка **OAuth 2.0**, **OpenID Connect**, **SAML**

**Что делает**:
1. **Аутентификация** — кто ты?    
2. **Авторизация** — что можно?    
3. **User Management** — управление пользователями    
4. **Social Login** — вход через Google, GitHub и т.д.    

**Для кого**:
- Приложения    
- API    
- Микросервисы    

**Альтернативы**: Auth0, Okta, AWS Cognito

---
# **Spring Data Envers**
**Spring Data Envers** — аудит и версионирование данных в БД.

 **Что это:**
- Автоматическое сохранение истории изменений сущностей    
- Отслеживание: кто, когда, что изменил    
- Восстановление предыдущих версий данных    

 **Для чего:**
1. **Аудит** — требования compliance (GDPR, SOX)    
2. **Отладка** — найти когда сломалось    
3. **Аналитика** — история изменений    
4. **Undo** — откат изменений    

**Как работает**:
- Создает ревизионные таблицы    
- Автоматически сохраняет старые версии    
- Интегрируется с Spring Security (кто изменил)    

 **Пример:**
```java
@Audited
@Entity
public class User {
    private String name;
    private String email;
}
```

**Альтернативы**: Hibernate Envers, ручное версионирование, temporal tables в БД.

---
# **`Docker Compose`** и **`Makefile`**

## **Docker Compose**
**Для чего**: Оркестрация многоконтейнерных приложений
**Как используется**:
```yaml
# docker-compose.yml
version: '3'
services:
  app:
    build: .
    ports: ["8080:8080"]
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myapp
```

**Запуск**:
```bash
docker-compose up -d        # запуск
docker-compose down         # остановка
docker-compose logs -f      # логи
```

## **Makefile**
**Для чего**: Автоматизация команд (*сборка, тесты, деплой*)
**Имя файла**: `Makefile` (без расширения)
**Как используется**:
```makefile
# Комментарии начинаются с решетки

# Переменные
APP_NAME = myapp
VERSION = 1.0.0

# Цели (targets)
build:
    docker build -t $(APP_NAME):$(VERSION) .

run:
    docker run -p 8080:8080 $(APP_NAME):$(VERSION)

test:
    go test -v ./...

clean:
    docker rmi $(APP_NAME):$(VERSION)

# Файловые зависимости
dist/app: src/main.go
    go build -o dist/app src/main.go

# Псевдоцели
.PHONY: build run test clean
```

**Запуск**:
```bash
make build    # сборка
make run      # запуск
make clean    # очистка
```
или
```bash
make build      # выполнит цель build
make run test   # выполнит run и test
make            # выполнит первую цель
```
 **Идеальное сочетание**:
- **Docker Compose** — управление контейнерами    
- **Makefile** — упрощение сложных команд

**Ключевые особенности**:
- **Табы** — отступы ДОЛЖНЫ быть табами, не пробелами!    
- **Цели** — команды которые можно выполнить    
- **Зависимости** — перестроение при изменении файлов    
- **Переменные** — для избежания дублирования    
- **.PHONY** — цели не связанные с файлами    

**Используется** для унификации команд в проекте.

---
# Nexus
**Nexus** — менеджер артефактов и репозиторий.

**Для чего:**
- Хранение бинарных артефактов (JAR, NPM, Docker, Python)    
- Проксирование внешних репозиториев (Maven Central, npmjs)    
- *Control* версий зависимостей    

**Что хранит:**
- Java: `.jar`, `.pom`    
- JavaScript: `.tgz` (npm пакеты)    
- Docker: образы    
- Python: `.whl`, `.egg`    
- System: RPM, DEB пакеты    

**Основные функции:**
1. **Кеширование** — ускорение сборок    
2. **Изоляция** — свои приватные артефакты    
3. **Безопасность** — контроль доступа    
4. **Стабильность** — независимость от внешних репозиториев    

**Альтернативы:**
- **JFrog Artifactory**    
- **GitHub Packages**    
- **GitLab Package Registry**    

**Итог**: Корпоративный хаб для всех бинарных артефактов в CI/CD.

---
# Postgres Explorer
**Postgres Explorer** — визуальный инструмент для работы с PostgreSQL.

**Что это:**
- GUI-клиент для администрирования PostgreSQL    
- Аналог: pgAdmin, DBeaver, DataGrip    

**Основные возможности:**
1. **Визуальное управление** БД, таблицами, индексами    
2. **SQL-редактор** с подсветкой syntax    
3. **Просмотр данных** в таблицах    
4. **Построение схем** БД    
5. **Управление пользователями** и правами    

**Для кого:**
- **Разработчики** — быстрый доступ к данным    
- **Админы БД** — управление схемой    
- **Аналитики** — выполнение запросов    

**Примеры инструментов:**
- **pgAdmin** — официальный от PostgreSQL    
- **DBeaver** — универсальный для всех БД    
- **DataGrip** — от JetBrains    
- **Navicat** — коммерческий    

**Суть**: Замена командной строки psql на удобный интерфейс для работы с PostgreSQL.

---
# **Exporter**
**Exporter** — специальное приложение, которое собирает метрики из системы и предоставляет их в формате **Prometheus**.

**Для чего:**
- Преобразует метрики приложений/систем в **Prometheus**-формат
- Делает неизмеряемые системы наблюдаемыми    

**Как работает:**
```text
Приложение/Система → Exporter → HTTP endpoint → Prometheus
```

**Примеры экспортеров:**
- **node_exporter** — метрики ОС (CPU, память, диск)    
- **postgres_exporter** — метрики PostgreSQL    
- **nginx_exporter** — метрики Nginx    
- **jmx_exporter** — метрики Java-приложений    
- **blackbox_exporter** — проверка доступности (HTTP, TCP)    

**Пример использования:**
```yaml
# docker-compose.yml
services:
  node_exporter:
    image: prom/node-exporter
    ports: ["9100:9100"]
  
  prometheus:
    image: prom/prometheus
    ports: ["9090:9090"]
```

**Конфигурация Prometheus:**
```yaml
scrape_configs:
  - job_name: 'node'
    static_configs:
      - targets: ['node_exporter:9100']
```

**Итог**: Экспортеры — мост между системами и Prometheus для сбора метрик.

---










