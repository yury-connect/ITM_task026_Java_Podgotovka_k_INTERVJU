

---
## ====Отличие **Rest** от **Soap**====
REST (Representational State Transfer) и SOAP (Simple Object Access Protocol) — это два различных подхода к созданию веб-сервисов. Вот основные отличия между ними:

### 1. Протоколы и стандарты
- **SOAP:**    
    - Протокол, который использует XML для передачи сообщений.
    - Поддерживает стандарты безопасности (WS-Security), транзакций и других.
    - Обычно работает поверх HTTP, но может использовать и другие протоколы (SMTP, TCP и др.).
- **REST:**    
    - Архитектурный стиль, не привязанный к конкретному протоколу.
    - Обычно использует HTTP и его методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами.
    - Может передавать данные в различных форматах (JSON, XML, HTML и др.), но чаще всего используется JSON.

### 2. Структура
- **SOAP:**    
    - Сообщения имеют строгую структуру, включающую заголовки и тело, что делает их более сложными.
    - Использует WSDL (Web Services Description Language) для описания доступных методов и их параметров.
- **REST:**    
    - Более гибкая и простая структура, основанная на ресурсах (например, URL).
    - Не требует специального описания, но может использовать OpenAPI (Swagger) для документирования.

### 3. Состояние
- **SOAP:**    
    - Обычно считается "состоянием" (stateful), что означает, что состояние может сохраняться между вызовами.
- **REST:**    
    - Является "бестатусным" (stateless), что означает, что каждый запрос от клиента к серверу должен содержать всю необходимую информацию для его обработки.

### 4. Использование
- **SOAP:**    
    - Часто используется в корпоративных приложениях, где требуется высокая безопасность и надежность (например, финансовые и банковские системы).
- **REST:**    
    - Чаще используется для создания веб-приложений и API, где важна простота и скорость (например, мобильные приложения, веб-сервисы).

### 5. Производительность
- **SOAP:**    
    - Из-за своей сложности и необходимости обработки XML-сообщений может быть медленнее.
- **REST:**    
    - Обычно более производителен благодаря легковесности JSON и простоте HTTP-запросов.

### Вывод
Выбор между REST и SOAP зависит от конкретных требований проекта. Если необходима высокая безопасность и сложные операции, лучше использовать SOAP. Если важна простота и скорость, предпочтительнее REST.

---
## ====**XML** vs **Json**====
ML (eXtensible Markup Language) и JSON (JavaScript Object Notation) — это два популярных формата для обмена данными. Вот основные отличия между ними:

### 1. Синтаксис
- **XML:**    
    - Использует теги для определения структуры данных.   
- **JSON:**    
    - Использует пары "ключ-значение" и имеет более компактный синтаксис.    

### 2. Читаемость
- **XML:**
    - Более громоздкий из-за использования тегов, что может усложнять чтение.
- **JSON:**
    - Более легкий и читаемый для человека, особенно в больших объемах данных.

### 3. Поддержка типов данных
- **XML:**
    - Все данные представлены в виде строк. Дополнительная информация о типах данных не поддерживается напрямую.
- **JSON:**
    - Поддерживает различные типы данных: строки, числа, массивы, объекты, булевы значения и null.

### 4. Обработка и парсинг
- **XML:**
    - Требует больше ресурсов для парсинга. Использует DOM или SAX для обработки.
- **JSON:**
    - Легче парсится, особенно в JavaScript, где он может быть преобразован в объект с помощью `JSON.parse()`.

### 5. Простота и гибкость
- **XML:**
    - Позволяет создавать сложные структуры и схемы. Подходит для более сложных документов, таких как конфигурационные файлы или документы с метаданными.
- **JSON:**
    - Более прост в использовании и подходит для передачи данных между клиентом и сервером, особенно в веб-приложениях.

### 6. Поддержка комментариев
- **XML:**    
    - Поддерживает комментарии.
- **JSON:**    
    - Не поддерживает комментарии, что делает его менее удобным для документирования структуры данных.

### 7. Применение
- **XML:**    
    - Часто используется в SOAP-сервисах, конфигурационных файлах, а также в системах, где требуется строгая структура данных.
- **JSON:**    
    - Широко используется в RESTful API, веб-приложениях и мобильных приложениях благодаря своей легкости и простоте.

---
## ====Как определить что твой сервис является **restfull**====
Чтобы определить, является ли ваш сервис RESTful, нужно проверить соответствие нескольким ключевым принципам и характеристикам архитектуры REST. Вот основные критерии:

### 1. Использование HTTP методов
- **GET:** Для получения данных.
- **POST:** Для создания новых ресурсов.
- **PUT:** Для обновления существующих ресурсов.
- **DELETE:** Для удаления ресурсов.

### 2. Идентификация ресурсов
- Каждый ресурс должен иметь уникальный URI (Uniform Resource Identifier), который позволяет его идентифицировать. Например:
    - `/users` для получения списка пользователей.
    - `/users/1` для получения информации о конкретном пользователе.

### 3. Статус кодов HTTP
- Используйте стандартные HTTP статус коды для обозначения результатов операций:
    - `200 OK` для успешного запроса.
    - `201 Created` для успешного создания ресурса.
    - `204 No Content` для успешного удаления ресурса.
    - `400 Bad Request` для ошибок в запросе.
    - `404 Not Found` для несуществующих ресурсов.
    - `500 Internal Server Error` для ошибок на сервере.

### 4. Бестатусность (Stateless)

- Каждый запрос от клиента должен содержать всю необходимую информацию для его обработки. Сервер не должен сохранять состояние клиента между запросами.

### 5. Кэшируемость

- Ответы сервера должны быть кэшируемыми, чтобы уменьшить количество запросов к серверу и улучшить производительность.

### 6. Уровни абстракции
- Используйте представления (например, JSON или XML) для передачи данных. Сервер должен предоставлять данные в удобном формате, а клиент может запрашивать нужный формат через заголовки.

### 7. Использование **`HATEOAS`** (*Hypermedia as the Engine of Application State*)

- Клиенты должны взаимодействовать с приложением через гипермедиа, получая ссылки на доступные действия и ресурсы в ответах.

---
## ====Расскажи про **двухфазный коммит**====
Двухфазный коммит (Two-Phase Commit, 2PC) — это протокол, используемый в распределённых системах для обеспечения согласованности данных при выполнении транзакций. Он гарантирует, что все участники транзакции либо завершат её успешно, либо откатят изменения, если хотя бы один участник не может завершить транзакцию.

### Этапы двухфазного коммита:

1. **Фаза подготовки (Prepare Phase):**    
    - **Инициатор:** Узел, который инициирует транзакцию, отправляет всем участникам запрос на подготовку (prepare request).
    - **Участники:** Каждый участник (узел) обрабатывает запрос и принимает решение о возможности завершения транзакции. Участник может либо согласиться (vote "yes"), либо отклонить (vote "no").
    - **Ответ:** Участники отправляют обратно инициатору свои ответы.
      
2. **Фаза завершения (Commit Phase):**    
    - **Если все участники согласны:** Инициатор получает положительные ответы от всех участников и отправляет команду на коммит (commit) всем участникам.
    - **Если хотя бы один участник отклоняет:** Инициатор получает хотя бы один отрицательный ответ и отправляет команду на откат (rollback) всем участникам.
    - **Завершение:** Все участники выполняют указания инициатора (либо фиксируют изменения, либо откатывают их).

### Преимущества:
- **Согласованность:** Обеспечивает согласованность данных в распределённых системах.
- **Безопасность:** Гарантирует, что данные не будут частично обновлены.

### Недостатки:
- **Блокировка:** В случае сбоя инициатора или участников транзакции система может заблокироваться, ожидая ответа.
- **Производительность:** Может снижать производительность из-за необходимости ожидания ответа от всех участников.

---
## ====**Монолит** vs **Микросервисы**====

Монолитные и микросервисные архитектуры — это два различных подхода к проектированию и разработке программного обеспечения. Вот основные отличия между ними:

### 1. Определение
- **Монолит:**    
    - Вся функциональность приложения разрабатывается и разворачивается как единое целое. Все компоненты (*интерфейс, бизнес-логика, база данных*) находятся в одном кодовом базе.
    
- **Микросервисы:**    
    - Приложение разбивается на множество небольших, независимых сервисов, каждый из которых отвечает за конкретную функциональность. Эти сервисы взаимодействуют друг с другом через API.

### 2. Структура

- **Монолит:**    
    - Все модули и компоненты связаны между собой и работают в одной среде. Изменение одного компонента может требовать пересборки и перезапуска всего приложения.
    
- **Микросервисы:**    
    - Каждый сервис разрабатывается, развертывается и масштабируется независимо. Это позволяет командам работать параллельно и быстрее внедрять изменения.

### 3. Масштабируемость
- **Монолит:**
    - Масштабирование требует развертывания всей системы, что может быть неэффективно.
    
- **Микросервисы:**    
    - Позволяют масштабировать отдельные сервисы в зависимости от нагрузки, что делает систему более эффективной.

### 4. Разработка и развертывание
- **Монолит:**    
    - Быстрая разработка на начальных этапах, но сложность увеличивается с ростом приложения. Обновления требуют полной перезагрузки приложения.
	
- **Микросервисы:**
    
    - Более сложная разработка, требующая управления множеством сервисов. Однако обновления могут выполняться поэтапно, без необходимости перезагрузки всей системы.

### 5. Технологический стек
- **Монолит:**    
    - Обычно использует один стек технологий для всего приложения, что может ограничивать гибкость.
      
- **Микросервисы:**
    
    - Позволяют использовать разные технологии и языки программирования для различных сервисов, что дает большую гибкость.

### 6. Тестирование
- **Монолит:**    
    - Тестирование может быть проще, так как все компоненты находятся в одной кодовой базе.
	
- **Микросервисы:**    
    - Требуют более сложного тестирования, включая интеграционные тесты и тесты взаимодействия между сервисами.

### 7. Устойчивость
- **Монолит:**    
    - Если один компонент выходит из строя, это может повлиять на всё приложение.
	
- **Микросервисы:**    
    - Если один сервис выходит из строя, остальные могут продолжать работать, что повышает устойчивость системы.

---
## ====Теорема **CAP**====
В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:  
  
- C (consistency) — согласованность. Каждое чтение даст вам самую последнюю запись.
- A (availability) — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись).
- P (partition tolerance) — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.
![Теорема CAP](./_Attachments_Вопросы&Ответы_001/Pasted%20image%2020241027200908.png)

## Проблемы CAP
- Далёкие от реального мира определения
- В рамках разработки, выбор в основном лежит между CP и AP
- Множество систем — просто P
- Чистые AP и CP системы могут быть не тем, что ожидаешь

### Что не так с определениями?
Consistency в CAP фактически означает линеаризуемость (и ее действительно трудно достичь). Чтобы объяснить, что такое линеаризуемость, давайте посмотрим на следующую картинку:
![Что не так с определениями](./_Attachments_Вопросы&Ответы_001/Pasted%20image%2020241106133621.png)

В описанном случае рефери закончил игру, но не каждый клиент получает один и тот же результат. Чтобы сделать его систему линеаризованной, нам нужно мгновенно синхронизировать данные между рефери и другими источниками данных, чтобы, когда рефери закончит игру, каждый клиент получил правильную информацию.  
  
Availability в CAP, исходя из определения имеет две серьёзные проблемы. Первая — нет понятия частичной доступности, или какой-то её степени (проценты например), а есть только полная доступность. Вторая проблема — неограниченное время ответа на запросы, т.е. даже если система отвечает час, она всё ещё доступна.

Устойчивость к распределению не включает в себя упавшие узлы, и вот почему:  
  
1. По определению. В availability так и прописано "...every node (if not failed) always..."
2. Исходя из доказательства. Доказательства CAP теоремы гласят что на узлах должен исполняться некоторый код.
3. Ну и немного моих (и не только) домыслов. В случае падения узла, система может восстановиться, пообщаться с другими узлами и продолжить работу как ни в чем ни бывало. В случае разделения сети — придётся ждать восстановления соединения.

Поэтому, нужно помнить про способность системы восстанавливаться, но за рамками CAP теоремы.

### AP / CP выбор

Коммуникация узлов между собой обычно происходит через асинхронную сеть, которая может задерживать или удалять сообщения. Интернет и все наши центры обработки данных обладают этим свойством, и это не маловероятные инциденты, поэтому CA системы в рамках разработки рассматриваются крайне редко.

### Многие системы — просто P
Представьте систему, в которой два узла (Master, Slave) и клиент. Если вдруг вы потеряли связь с Master, клиент может читать из Slave, но не может писать — нет CAP-availability.  
  
Ок, вроде CP система, но если Master и Slave синхронизируются асинхронно, то клиент, может запросить данные от Slave раньше успешной синхронизации — теряем CAP-consistency.
![|735x397](./_Attachments_Вопросы&Ответы_001/Pasted%20image%2020241106133705.png)

### Чистые AP и CP системы
Чистые AP системы, могут включать в себя просто 2 генератора чисел. Чистые CP системы, могут вообще не быть доступны, т.к. буду пытаться придти к согласованному состоянию и не будут нам отвечать. Идём дальше, CP системы дают нам не ожидаемый нами strong consistency, а eventual consistency. О нём поговорим чуть позже.

Как с этим жить

В конце концов, это всего лишь попытка классифицировать что-то абстрактное, поэтому вам не нужно изобретать велосипед. Я рекомендую использовать следующий подход при попытке работать с распределенными БД:

- Помните об определениях CAP и об их ограничениях.
- Используйте теорему PACELC вместо CAP, она позволяет взглянуть на систему ещё с одного ракурса.
- Помните про принципы ACID/ BASE и насколько они применимы к вашей системе.
- Любые телодвижения следует делать, учитывая проект, над которым вы работаете.

---
## ====**PACELC**====
Вся теорема сводится к IF P -> (C or A), ELSE (C or L).

Latency — это время, за которое клиент получит ответ и которое регулируется каким-либо уровнем consistency. Latency (задержка), в некотором смысле представляет собой степень доступности
![|741x417](./_Attachments_Вопросы&Ответы_001/Pasted%20image%2020241106133828.png)

### Немного о **BASE**
BASE — это своеобразный контраст ACID, который говорит нам, что истинная согласованность не может быть достигнута в реальном мире и не может быть смоделирована в высокомасштабируемых системах.

Что стоит за **BASE**:    

- Basic Availability. Система отвечает на любой запрос, но этот ответ может быть содержать ошибку или несогласованные данные.
- Soft-state. Состояние системы может меняться со временем из-за изменений конечной согласованности.
- Eventual consistency (конечная согласованность). Система, в конечном итоге, станет согласованной. Она будет продолжать принимать данные и не будет проверять каждую транзакцию на согласованность.

Меня несколько раз спрашивали о том, что лучше ACID или BASE — это зависит от вашего проекта. Например, если ваши данные не критичны, и пользователь действительно заботится о скорости взаимодействия, BASE будет лучшим вариантом. Если всё наоборот — ACID поможет вам сделать систему максимально надежной с точки зрения данных.

---
