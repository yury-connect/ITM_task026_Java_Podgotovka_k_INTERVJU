---
tags:
  - TECHNOLOGIES/Microsevices
  - TECHNOLOGIES/Microsevices/Шаблон
---
## Шаблон **микросервиса** на **Spring Boot** *(многомодульный проект)*

Ниже приведён обновлённый шаблон проекта, адаптированный под вашу структуру с двумя модулями: `user-service-api` (контракты, DTO, события) и `user-service-src` (реализация). Включены лучшие практики:

- **Многомодульная архитектура** (API vs Implementation)
- **Чистая структура** каталогов
- **Контракты** (DTO, модели, события) в отдельном модуле
- **MapStruct** для маппинга
- **Валидация** через Jakarta Validation
- **Глобальная обработка ошибок**
- **OpenAPI/Swagger**
- **Actuator + Prometheus**
- **Контейнеризация** (Dockerfile на уровне корня)
- **CI/CD** (пример .gitlab-ci.yml)

---
### 1. Структура проекта

```
be-java-advice-user-service/
├── .gitlab-ci.yml
├── .gitignore
├── pom.xml                    # Parent POM
├── Dockerfile
├── README.md
├── user-service-api/
│   ├── pom.xml                # API-модуль: контракты
│   └── src/main/java/com/itm/space/userservice/api
│       ├── dto                # DTO для контроллеров и clients
│       ├── model              # интерфейсы и базовые сущности (например BaseEntity)
│       ├── events             # модели событий для Kafka
│       └── response           # модели ответа (projection)
└── user-service-src/
    ├── pom.xml                # Реализация: сервис, контроллеры, репозитории
    └── src
        ├── main/java/com/itm/space/userservice
        │   ├── UserServiceApplication.java
        │   ├── config          # OpenAPI, Actuator, Security
        │   ├── controller      # REST-эндпоинты
        │   ├── service         # бизнес-логика
        │   ├── repository      # Spring Data JPA
        │   └── security        # настройка авторизации (например Keycloak)
        └── test
            ├── java/com/itm/space/userservice
            └── resources/json  # JSON-файлы для контрактных тестов
                ├── controller
                ├── repository
                └── kafka
```

---
### 2. Родительский `pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0">
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.itm.space</groupId>
  <artifactId>be-java-advice-user-service</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <packaging>pom</packaging>

  <properties>
    <java.version>17</java.version>
    <spring.boot.version>3.1.0</spring.boot.version>
    <mapstruct.version>1.5.3.Final</mapstruct.version>
  </properties>

  <modules>
    <module>user-service-api</module>
    <module>user-service-src</module>
  </modules>

  <dependencyManagement>
    <dependencies>
      <!-- Spring Boot BOM -->
      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring.boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
      <!-- MapStruct BOM -->
    </dependencies>
  </dependencyManagement>
</project>
```

---
### 3. `user-service-api/pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0">
  <parent>
    <groupId>com.itm.space</groupId>
    <artifactId>be-java-advice-user-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>user-service-api</artifactId>
  <packaging>jar</packaging>

  <dependencies>
    <!-- Jakarta Validation -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <!-- MapStruct -->
    <dependency>
      <groupId>org.mapstruct</groupId>
      <artifactId>mapstruct</artifactId>
      <version>${mapstruct.version}</version>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>${java.version}</source>
          <target>${java.version}</target>
          <annotationProcessorPaths>
            <path>
              <groupId>org.mapstruct</groupId>
              <artifactId>mapstruct-processor</artifactId>
              <version>${mapstruct.version}</version>
            </path>
          </annotationProcessorPaths>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

---
### 4. `user-service-src/pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0">
  <parent>
    <groupId>com.itm.space</groupId>
    <artifactId>be-java-advice-user-service</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  <artifactId>user-service-src</artifactId>
  <packaging>jar</packaging>

  <dependencies>
    <!-- API контракт -->
    <dependency>
      <groupId>com.itm.space</groupId>
      <artifactId>user-service-api</artifactId>
      <version>${project.version}</version>
    </dependency>
    <!-- Spring Boot Starters -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
    </dependency>
    <!-- OpenAPI -->
    <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    </dependency>
    <!-- Actuator + Prometheus -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    <dependency>
      <groupId>io.micrometer</groupId>
      <artifactId>micrometer-registry-prometheus</artifactId>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>
```

---

### 5. Основные пакеты и классы

#### 5.1 `UserServiceApplication.java`
```java
package com.itm.space.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}
```

#### 5.2 Controller, Service, Repository, Mapper
Разместите классы в пакетах согласно структуре: `controller`, `service`, `repository`, `mapper`. Используйте DTO из модуля `user-service-api`.

#### 5.3 События Kafka
Модели событий (в `user-service-api/src/main/java/.../events`) публикуйте через Spring Kafka (добавить dependency `spring-kafka`).

---
### 6. Dockerfile (в корне проекта)

```dockerfile
FROM eclipse-temurin:17-jdk-jammy
WORKDIR /app
COPY user-service-src/target/user-service-src-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

---
### 7. CI/CD (`.gitlab-ci.yml`)

```yaml
stages:
  - build
  - test
  - package

build:
  stage: build
  script:
    - mvn clean compile --projects user-service-api,user-service-src

test:
  stage: test
  script:
    - mvn test

package:
  stage: package
  script:
    - mvn package -DskipTests
    - docker build -t user-service .
```

---
---
---
В многомодульной архитектуре мы выделяем **контракты** (API) и **реализацию** в разные модули, чтобы повысить гибкость, переиспользуемость и изоляцию зависимостей.

---
## Почему два модуля?

1. **Разделение ответственности**
    
    - **API‑модуль** содержит всё, что нужно потребителям вашего сервиса (другим микросервисам, клиентским приложениям): DTO, интерфейсы, модели событий.
        
    - **Implementation‑модуль** содержит детали внутренней реализации: контроллеры, сервисы, репозитории, security‑конфигурацию, миграции БД и пр.
        
2. **Изоляция зависимостей**
    
    - Клиентам нужен только API‑модуль: они не «тянут» на себя JPA, Kafka, Spring Boot, Actuator и т. д.
        
    - Реализация подключает API‑модуль как зависимость и добавляет все «весовые» библиотеки.
        
3. **Удобство версионирования и контрактного тестирования**
    
    - Когда API‑модуль меняется (добавляем новое поле в DTO или событие), его можно версиировать отдельно, не затрагивая реализацию.
        
    - Контрактные (consumer‑driven) тесты читают схемы DTO/событий из API‑модуля, гарантируя, что реализация не сломает потребителей.
        
4. **Ускорение сборки**
    
    - При изменении только API‑модуля не нужно пересобирать всю реализацию — достаточно модуля `user-service-api`.
        
5. **Чистая архитектура**
    
    - Это один из способов следовать принципам чистой архитектуры (Separate Interface and Implementation).
        

---

## Что пишем в каждом модуле

### 1. `user-service-api`

- **DTO** (`/dto`) — входные и выходные модели REST (например, `UserDto`).
    
- **Модели событий** (`/events`) — классы, которые будут сериализоваться в Kafka (например, `UserCreatedEvent`).
    
- **Интерфейсные модели/проекции** (`/response`, `/model`) — интерфейсы и базовые абстракции (например, `BaseEntity`, `UserSummary`).
    
- **Контракты в виде Java‑интерфейсов** — описываем API‑контракты для Feign‑клиентов или OpenAPI‑плагинов.
    
- **Зависимости**: только MapStruct, Jakarta Validation и, при необходимости, Spring‑вещи, необходимые для аннотаций в DTO.
    

### 2. `user-service-src`

- **Application‑класс** (`UserServiceApplication.java`) — точка входа.
    
- **`config`** — настройка OpenAPI, Actuator, Security (Keycloak, OAuth2) и др.
    
- **`controller`** — REST‑эндпоинты, аннотированные Spring MVC.
    
- **`service`** — бизнес‑логика, оркестрация репозиториев и отправки событий.
    
- **`repository`** — Spring Data JPA‑интерфейсы для доступа к БД.
    
- **`mapper`** — мапперы MapStruct, реализующие перевод между `entity` и DTO из API‑модуля.
    
- **`security`** — конфигурация авторизации (в т. ч. интеграция с Keycloak).
    
- **тесты** (`/test`) — unit и интеграционные тесты (включая контрактные тесты против JSON‑файлов из API‑модуля).
    
- **зависимости**: Spring Boot Web, Data JPA, Postgres Driver, Springdoc‑OpenAPI, Actuator, Kafka (если нужны события), и любой другой «весовой» стек.
    

---

### Итог

Такое разделение:

- **Упрощает совместную работу**: команды, работающие над API‑контрактами, изолированы от команды интеграторов реализации.
    
- **Повышает надёжность**: контрактный тест гарантирует, что реализация соответствует ожиданиям потребителя.
    
- **Ускоряет CI**: не каждое изменение триггерит пересборку всего большого модуля.
    

Если остались вопросы по конкретным деталям каждого пакета или примерам кода, дайте знать!

