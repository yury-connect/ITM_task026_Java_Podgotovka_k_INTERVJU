# **Паттерны межсервисного взаимодействия**

Сравнительный анализ, принципы и рекомендации по выбору

---
## **1. Синхронные паттерны**

### 1.1. **Request/Response** (REST, gRPC, GraphQL)
**Что это:**  
Прямые HTTP-вызовы между сервисами с ожиданием немедленного ответа.

**Разновидности:**
- **REST** – JSON/XML over HTTP, кешируемость, стандартные методы (GET/POST/PUT/DELETE).
    
- **gRPC** – бинарный протокол на основе HTTP/2, поддерка стриминга (Unary, Server/Client/ Bidirectional).
    
- **GraphQL** – гибкие запросы с выборкой только нужных полей.

**Когда применять:**
- Нужен мгновенный ответ (*проверка баланса, бронирование*).    
- Простые сценарии с **малым** количеством сервисов.

**Плюсы:**  
✅ Простота реализации  
✅ Понятность и стандартизация (*особенно REST*)

**Минусы:**  
❌ Жесткая связанность (*сервис недоступен → ошибка*)  
❌ Нет гарантии доставки

---
### 1.2. **API Gateway**
**Что это:**  
Единая точка входа для клиентов, которая маршрутизирует запросы к микросервисам.

**Основные функции:**
- Аутентификация/авторизация (`OAuth2`, `JWT`)    
- Балансировка нагрузки (`Round Robin`, `Least Connections`)    
- Кеширование, компрессия, трансформация данных    

**Когда применять:**
- Есть внешние клиенты (*мобильные приложения, фронтенд*).    
- Нужна единая точка управления доступом.    

**Плюсы:**  
✅ Централизованное управление трафиком  
✅ Снижение нагрузки на сервисы (*кеширование*)

**Минусы:**  
❌ Риск превращения в "монолит" (логика агрегации усложняется)  
❌ Single Point of Failure (требует кластеризации)

---
### **1.3. Circuit Breaker**

**Что это:**  
Паттерн для предотвращения каскадных сбоев. При частых ошибках временно блокирует вызовы.

**Состояния:**
- **`Closed`** – запросы проходят.    
- **`Open`** – вызовы блокируются, возвращается `fallback`.    
- **`Half-Open`** – пробует пропустить часть запросов для проверки.    

**Когда применять:**
- Сервис может быть недоступен (*сетевые проблемы, перегрузка*).    
- Критично избежать каскадных сбоев.    

**Плюсы:**  
✅ Повышает отказоустойчивость  
✅ Защищает от перегрузки

**Минусы:**  
❌ Требует настройки порогов срабатывания  
❌ `Fallback`-логика усложняет код

---
## **2. Асинхронные паттерны**

### 2.1. **Event-Driven** (`Pub/Sub`, `Event Sourcing`)
**Что это:**  
Сервисы обмениваются событиями через брокер сообщений (`Kafka`, `RabbitMQ`).

**Разновидности:**
- **`Pub/Sub`** – издатель (`Publisher`) → `топик` → `подписчики` (*Subscribers*).    
- **`Event Sourcing`** – хранение всех изменений состояния как событий.    

**Когда применять:**
- Сложные бизнес-процессы (`заказ` → `оплата` → `доставка`).    
- Нужна <u>слабая связанность</u> и <u>масштабируемость</u>.    

**Плюсы:**  
✅ Горизонтальное масштабирование  
✅ Отложенная обработка (**`peak load`**)

**Минусы:**  
❌ Сложность отладки (**`event chains`**)  
❌ Требует идемпотентности

---
### **2.2. Saga**
**Что это:**  
Управление распределенными транзакциями через цепочку локальных транзакций с компенсациями.

**Типы:**
- **Хореография** – сервисы <u>сами</u> запускают события.    
- **Оркестрация** – <u>центральный</u> координатор (`Orchestrator`).    

**Когда применять:**
- Транзакции, затрагивающие несколько сервисов 
	  (*например, бронирование отеля + авиабилетов*).

**Плюсы:**  
✅ Нет распределенных блокировок  
✅ Отказоустойчивость (*компенсирующие транзакции*)

**Минусы:**  
❌ Сложная реализация откатов  
❌ Не подходит для high-load в оркестрационном подходе

---
## **3. Гибридные подходы**

### 3.1. **Backend for Frontend** (BFF)
**Что это:**  
Отдельный шлюз для каждого типа клиента (*Web, Mobile, API*), который агрегирует данные.

**Когда применять:**
- Разные клиенты требуют разных форматов данных.    

**Плюсы:**  
✅ Оптимизация данных под клиента  
✅ Снижение нагрузки на основной API

**Минусы:**  
❌ Дублирование логики между BFF

---
## **Сравнительная таблица**

| Паттерн/ наименование | Связанность | Масштабируемость | Отказоустойчивость | Сложность |
| --------------------- | ----------- | ---------------- | ------------------ | --------- |
| **REST/gRPC**         | Высокая     | Средняя          | Низкая             | Низкая    |
| **Event-Driven**      | Низкая      | Высокая          | Высокая            | Средняя   |
| **Saga**              | Средняя     | Средняя          | Высокая            | Высокая   |
| **API Gateway**       | Зависит     | Высокая          | Средняя            | Средняя   |

---
## **Итоговые рекомендации**

- Для **монолитной миграции** → **`REST` + `API Gateway`**    
- Для **сложных процессов** → **`Event-Driven` + `Saga`**    
- Для **high-load** → **`gRPC` + `Kafka`**    
- Для **клиентских** приложений → **`BFF` + `GraphQL`**    

Выбор зависит от требований к связанности, отказоустойчивости и нагрузке.
