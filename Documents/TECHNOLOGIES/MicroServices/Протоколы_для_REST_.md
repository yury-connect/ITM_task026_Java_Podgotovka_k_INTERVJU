### **Протоколы для REST-взаимодействия между сервисами**

При REST-коммуникации между микросервисами обычно используется **HTTP/HTTPS** как базовый транспортный протокол. Однако есть нюансы в зависимости от требований к безопасности, производительности и окружению.

---
## 1. **Основной протокол: `HTTP`/`HTTPS`**

### **Когда применяется:**
- **Внутри доверенной сети (*Kubernetes, private cloud*)** → часто **HTTP** 
	  (*без шифрования*).
    
- **Внешнее взаимодействие или строгие требования безопасности** → **HTTPS** 
	  (***TLS**-шифрование*).

### **Почему HTTP/HTTPS?**
✅ **Стандартизирован** (*RFC 7231, RFC 7540 для HTTP/2*).  
✅ **Поддержка всеми языками и фреймворками** (*Spring Boot, Express, Flask и др*.).  
✅ **Гибкость** (*JSON/XML, разные методы: GET, POST, PUT, DELETE*).

### **Ограничения:**
❌ **Низкая производительность** по сравнению с бинарными протоколами (*gRPC*).  
❌ **Нет встроенной семантики retry/timeout** 
	(*требует доп. библиотек, например, Resilience4j*).

---
## 2. **`HTTP/1.1` vs `HTTP/2`**

### **HTTP/1.1**
- **Работает по текстовому протоколу**.    
- **Один запрос — одно соединение** 
	  (*риск линейного роста `latency` при **множестве** вызовов*).
    
- **Пример заголовка:**
```http
GET /api/users/123 HTTP/1.1
Host: example.com
Accept: application/json
```

### **HTTP/2**
- **Бинарный протокол, мультиплексирование запросов** 
	  (*много запросов в одном TCP-соединении*).
- **Поддержка `Server Push`** (*редко используется в REST*).    
- **Снижает задержки** (*особенно для цепочек вызовов между сервисами*).    

**Когда переходить на HTTP/2:**
- Высоконагруженные системы с множеством параллельных запросов.
- Сервисы с частыми зависимыми вызовами (например, GraphQL BFF).

---
## **3. Дополнительные протоколы и оптимизации**

### **gRPC** (как альтернатива REST)
- Работает поверх **HTTP/2**, но использует бинарный формат (**Protocol Buffers**).    
- Лучше для **высоконагруженных систем** (например, финансовые транзакции).    

### **Service Mesh** (Istio, Linkerd)
- Добавляет **mTLS** для всех HTTP-вызовов между сервисами автоматически.    
- Внутри кластера Kubernetes часто используется **HTTP/2 + TLS**.    

### **WebSockets**
- Для long-lived соединений (чаты, уведомления).    
- Не является классическим REST, но иногда комбинируется.    

---
## **4. Безопасность**

### **Обязательные практики:**

1. **HTTPS** (TLS 1.2/1.3) для всех внешних и межсервисных вызовов.
    
2. **Аутентификация:**    
    - **JWT** (в заголовке `Authorization: Bearer <token>`).        
    - **API Keys** (например, `X-API-Key: abc123`).        
    - **mTLS** (взаимная проверка сертификатов).
    
3. **Заголовки безопасности:**    
    - `Strict-Transport-Security (HSTS)`.        
    - `Content-Security-Policy`.        

### **Пример безопасного REST-запроса:**
```http
GET /api/orders/456 HTTP/1.1
Host: orders.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Accept: application/json
X-Correlation-ID: 123e4567-e89b-12d3-a456-426614174000
```

---
## **5. Когда REST — не лучший выбор?**
- **Нужна максимальная производительность** → **gRPC**.    
- **Сложная event-архитектура** → **Kafka (Pub/Sub)**.    
- **Реалтайм-обновления** → **WebSockets/Server-Sent Events (SSE)**.    

---
## **Итог**

- **Стандарт для REST:** **HTTP/1.1 или HTTP/2** (*предпочтительно с TLS*).    
- **Для безопасности:** **HTTPS + JWT/mTLS**.    
- **Для оптимизации:** HTTP/2 + сжатие (*gzip, Brotli*).    
- **Альтернативы:** gRPC (*бинарный*), WebSockets (*реалтайм*).    

Выбор зависит от требований к latency, безопасности и инфраструктуре (*Kubernetes, облако, on-premise*).
