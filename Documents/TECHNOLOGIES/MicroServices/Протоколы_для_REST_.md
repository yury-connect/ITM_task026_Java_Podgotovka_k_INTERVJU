### **Протоколы для REST-взаимодействия между сервисами**

При REST-коммуникации между микросервисами обычно используется **HTTP/HTTPS** как базовый транспортный протокол. Однако есть нюансы в зависимости от требований к безопасности, производительности и окружению.

---
## 1. **Основной протокол: `HTTP`/`HTTPS`**

### **Когда применяется:**
- **Внутри доверенной сети (*Kubernetes, private cloud*)** → часто **HTTP** 
	  (*без шифрования*).
    
- **Внешнее взаимодействие или строгие требования безопасности** → **HTTPS** 
	  (***TLS**-шифрование*).

### **Почему HTTP/HTTPS?**
✅ **Стандартизирован** (*RFC 7231, RFC 7540 для HTTP/2*).  
✅ **Поддержка всеми языками и фреймворками** (*Spring Boot, Express, Flask и др*.).  
✅ **Гибкость** (*JSON/XML, разные методы: GET, POST, PUT, DELETE*).

### **Ограничения:**
❌ **Низкая производительность** по сравнению с бинарными протоколами (*gRPC*).  
❌ **Нет встроенной семантики retry/timeout** 
	(*требует доп. библиотек, например, Resilience4j*).

---
## 2. **`HTTP/1.1` vs `HTTP/2`**

### **HTTP/1.1**
- **Работает по текстовому протоколу**.    
- **Один запрос — одно соединение** 
	  (*риск линейного роста `latency` при **множестве** вызовов*).
    
- **Пример заголовка:**
```http
GET /api/users/123 HTTP/1.1
Host: example.com
Accept: application/json
```

### **HTTP/2**
- **Бинарный протокол, мультиплексирование запросов** 
	  (*много запросов в одном TCP-соединении*).
- **Поддержка `Server Push`** (*редко используется в REST*).    
- **Снижает задержки** (*особенно для цепочек вызовов между сервисами*).    

**Когда переходить на HTTP/2:**
- Высоконагруженные системы с множеством параллельных запросов.
- Сервисы с частыми зависимыми вызовами (например, GraphQL BFF).

---
## **3. Дополнительные протоколы и оптимизации**

### **gRPC** (*как альтернатива REST*)
- Работает поверх **HTTP/2**, но использует бинарный формат (**Protocol Buffers**).    
- Лучше для **высоконагруженных систем** (например, финансовые транзакции).    

### **Service Mesh** (*Istio, Linkerd*)
- Добавляет **mTLS** для всех HTTP-вызовов между сервисами автоматически.    
- Внутри кластера Kubernetes часто используется **HTTP/2 + TLS**.    

### **WebSockets**
- Для `long-lived` соединений (*чаты, уведомления*).    
- Не является классическим REST, но иногда комбинируется.    

---
## **4. Безопасность**

### **Обязательные практики:**

1. **HTTPS** (TLS 1.2/1.3) для всех внешних и межсервисных вызовов.
    
2. **Аутентификация:**    
    - **JWT** (в заголовке `Authorization: Bearer <token>`).        
    - **API Keys** (например, `X-API-Key: abc123`).        
    - **mTLS** (взаимная проверка сертификатов).
    
3. **Заголовки безопасности:**    
    - `Strict-Transport-Security (HSTS)`.        
    - `Content-Security-Policy`.        

### **Пример безопасного `REST`-запроса:**
```http
GET /api/orders/456 HTTP/1.1
Host: orders.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Accept: application/json
X-Correlation-ID: 123e4567-e89b-12d3-a456-426614174000
```

---
## **5. Когда REST — не лучший выбор?**
- **Нужна максимальная производительность** → **`gRPC`**.    
- **Сложная event-архитектура** → **`Kafka`** (Pub/Sub).    
- **Реалтайм-обновления** → **`WebSockets`/`Server-Sent Events` (SSE)**.    

---
## **Итог**

- **Стандарт для REST:** **HTTP/1.1 или HTTP/2** (*предпочтительно с TLS*).    
- **Для безопасности:** **HTTPS + JWT/mTLS**.    
- **Для оптимизации:** HTTP/2 + сжатие (*gzip, Brotli*).    
- **Альтернативы:** gRPC (*бинарный*), WebSockets (*реалтайм*).    

Выбор зависит от требований к latency, безопасности и инфраструктуре (*Kubernetes, облако, on-premise*).

---
---
---
# **Межсервисное взаимодействие: <br>`HTTP` как стандарт**

**Да, в большинстве случаев микросервисы общаются между собой по HTTP** (чаще HTTPS), особенно если используется REST-подход. Однако есть важные нюансы:

---
## **1. Почему HTTP?**

- **Универсальность**: Поддержка всеми языками и фреймворками (Spring Boot, Express, Flask и др.).
    
- **Человекочитаемость**: JSON/XML-форматы удобны для дебага и логов.
    
- **Инструментарий**: Готовые клиенты (Feign, Retrofit), прокси (Nginx), мониторинг (Prometheus).
    

**Пример типичного вызова:**
```http
GET /api/users/123 HTTP/1.1  
Host: user-service.internal  
Accept: application/json  
Authorization: Bearer <JWT>  
```

---
## **2. Когда HTTP — не лучший выбор?**

|Сценарий|Проблема HTTP|Альтернатива|
|---|---|---|
|Высоконагруженные системы|Высокие накладные расходы|gRPC (HTTP/2 + Protobuf)|
|Реалтайм-обновления|Нет push-уведомлений|WebSockets, SSE|
|Сложная event-архитектура|Отсутствие гарантий доставки|Kafka, RabbitMQ|

---
## **3. Детали HTTP-взаимодействия**

### **a) Версии протокола**
- **HTTP/1.1**:    
    - Текстовый формат.        
    - Одно соединение на запрос (риск latency).
        
- **HTTP/2**:    
    - Бинарный протокол, мультиплексирование.        
    - Лучшая производительность для цепочек вызовов.        

### **b) Безопасность**
- **HTTPS (TLS)** — обязательно для продакшена.
    
- **Аутентификация**:    
    - JWT в заголовке `Authorization`.        
    - mTLS (взаимная проверка сертификатов).        

### **c) Оптимизации**
- **Сжатие**: gzip/Brotli для JSON.    
- **Кеширование**: Заголовки `Cache-Control`, `ETag`.    

---
## **4. Что используют в `Kubernetes`/Se`rvice Mesh`?**
- **Istio/Linkerd**: Автоматически внедряют mTLS для HTTP-трафика между подами.    
- **HTTP/2**: Чаще используется для gRPC, но поддерживается и для REST.    

---
## **5. Золотые правила**

1. **Всегда HTTPS** (*даже внутри кластера*).
    
2. **Используйте idempotency-keys** для повторных запросов.
    
3. **Ограничивайте время ответа**:
```java
// Spring RestTemplate  
restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory());  
((HttpComponentsClientHttpRequestFactory) factory).setConnectTimeout(1000);  
```
    
4. **Логируйте correlation-id** для трассировки.    

---
## **Вывод**

**HTTP (особенно HTTP/2 + HTTPS) — стандарт де-факто для REST-взаимодействия микросервисов**, но для специфичных сценариев (high-load, реалтайм) лучше рассмотреть gRPC или messaging-брокеры.
