# Валидация токенов

Для всех современных языков программирования написаны библиотеки для создания и валидации JWT, писать этот код вручную нет никакого смысла, но понимать, как это происходит важно.

![Валидация токенов](Валидация_токенов.png)

#### **Что тут происходит:**
1. Извлекаем JWT из заголовка запроса
2. определяем алгоритм шифрования токена. (параметр “header.alg”)
3. при помощи алгоритма, шифруем:    **`header` + “`.`” + `payload**
4. сравниваем полученное значение с третьей частью токена (*signature*)  
	Значения **совпали**? — идем дальше. 
	**Нет**? — возвращаем на клиент #401
5. проверяем срок годности токена. (“`payload.exp`”)  
	Срок не истек? — идем дальше.  
	Истек? — возвращаем #401
6. дополнительно можно проверить ост-е параметры `payload`: `iss`, sub, `aud`, `nbf`
7. отдаем на клиент запрошенные данные

---
## **Black-list** токенов
Когда мы выходим из учетной записи, или сбрасываем пароль, нам нужно отозвать ранее выданные токены, чтобы никто уже не смог зайти с ними в приложение. Для этого токены добавляются в специальный «черный список». При проверке токена мы сначала проверяем, не добавлен ли он в этот список, а затем уже валидируем его, как было описано выше. Если токен найден в «черном списке», возвращаем #401.

Токен — коротко живущая информация. Чтобы токены не накапливались в «черном списке» их можно периодически удалять, но проще — использовать специальную базу данных с поддержкой **TTL** (*Time to Live*). Такие БД (например [Redis](https://redis.io/)) позволяют назначить записи срок годности, после истечения которого данные будут удалены автоматически.

> **Вопрос**: если мы используем БД с поддержкой TTL, зачем нам вообще «черный список»? Можно просто хранить все токены в БД, удалять отозванные, и проверять, есть ли такой токен при каждом запросе.
> **Ответ**: конечно можно, но количество таких токенов будет существенно больше. Это увеличит объем потребляемой памяти, и замедлит запросы к БД. больше данных => медленнее поиск в БД.

---
## Контроль версий

**Разберем ситуацию**:
- Ваши учетные данные были украдены.
- Злоумышленник входит в приложение от вашего имени и получает пару токенов. Когда срок жизни токенов истекает, он запрашивает новые в обмен на **`refresh token`**, и т. д.
- Вы узнаете, что страница взломана и сбрасываете пароль. Но, вы <u>не можете отозвать все старые токены</u> потому, что у вас их **нет**, они <u>нигде не хранятся</u>.

Чтобы решить эту проблему используют «***контроль версий учетных данных***»
- В таблицу нашей БД, где хранятся учетные данные, добавляем поле «**`version`**»    
- При создании `refresh` токена добавляем поле «**`version`**» в `payload` токена.    
- При каждой проверке `refresh` токена сверяем номер версии с номером из БД    
- Если номер версии <u>не совпал</u>, возвращаем #`401`    

> **Вопрос:** а чем это лучше, чем хранить сам `refresh` токен в базе данных?
> **Ответ:** Утечка данных из БД (*такое бывает*) никогда не приведет к утечке токенов, а украденный *хеш* пароля ничего не даст злоумышленнику, потому что его невозможно дешифровать.

---
источник: *статья на `habr.com`: [**Подробно про `JWT`**](https://habr.com/ru/articles/842056/)*
