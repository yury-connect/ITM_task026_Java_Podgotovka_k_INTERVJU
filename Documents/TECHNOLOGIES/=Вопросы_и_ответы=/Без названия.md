Вот краткие, чёткие и содержательные ответы на типичные вопросы по теме **Records + Generics** для уровня Java Middle (собеседование 2024–2026):

---
# Место № 20 // 29 интервью из 75
## 1. **Чем record отличается от обычного класса?**
- Неизменяемый (immutable) по умолчанию
- Автоматически генерирует: `equals()`, `hashCode()`, `toString()`, геттеры
- Все поля — `private final`
- Нельзя наследоваться от другого класса (кроме `java.lang.Record`)
- Нельзя быть абстрактным
- Запрещено менять состояние после создания (нет сеттеров)
- Очень компактный синтаксис
> Коротко: record — это «value class» / «data carrier» с минимумом бойлерплейта.

## 2. **Ограничения record** <br>(наследование, поля, конструктор)    
- **Наследование** — нельзя extends другой класс (только implicit от Record)
- **Реализация интерфейсов** — можно
- **Поля** — только те, что в заголовке record (добавлять обычные поля нельзя)
- **Конструкторы** —
	- есть канонический (с параметрами всех компонент)
    - можно добавлять дополнительные конструкторы
    - можно переопределять канонический (compact constructor)
- Нельзя объявлять не-final поля
- Нельзя добавлять методы, которые меняют состояние компонент

## 3. **Wildcards: extends и super**<br>(**PECS** — Producer Extends, Consumer Super)    
```java
List<? extends Number> producer  → можно только читать (get → Number)
List<? super   Integer> consumer → можно только писать (add → Integer или ниже)
```

| Wildcard        | Где <br>обычно используется        | Что <br>можно делать | Что нельзя                            |
| :-------------- | :--------------------------------- | :------------------- | :------------------------------------ |
| `? extends T`   | Producer <br>(возвращает элементы) | get → T              | add (кроме null <br>в редких случаях) |
| `? super T`     | Consumer <br>(принимает элементы)  | add → T              | get → только Object                   |
| `? (unbounded)` | Не знаем тип вообще                | get → Object         | add → почти ничего                    |

## 4. **Type Erasure** — что это и как проявляется?    
- На этапе компиляции вся информация о generic-типах сохраняется
- После компиляции (в байт-коде) `generic`-типы стираются → остаются `raw`-типы
- `List<String>` → `List` в runtime
- Проблемы, которые из-за этого возникают:
   - Нельзя `new T()`
   - Нельзя `new T[]`
   - Нельзя `instanceof List<String>` *(только raw или unbounded wildcard)*
   - Нельзя создать массив generic-типов `T[] arr = new T[10]`;
- Решения: `Type Token, Class<T>`, супертип-токены (Gson, Jackson)

## 5. **Bounded Type Parameters** — что это?
```java
<T extends Number & Comparable<T>>   // верхняя граница (upper bound)
<T super   Number>                   // нижняя граница (lower bound) — редко
```
- `<T extends A & B & C>` — T должен реализовывать/наследоваться от всех
- Часто используется в утилитных методах, коллекциях, компараторах
- Пример:
```java
public static <T extends Comparable<? super T>> T max(T a, T b) { ... }
```

---
# Место № 19 // 32 интервью из 75

##  6. **Future** vs **CompletableFuture** — главные отличия

|Характеристика|Future (Java 5)|CompletableFuture (Java 8+)|
|---|---|---|
|Можно вручную завершить|Нет|Да (complete(), completeExceptionally())|
|Композиция / chaining|Нет (только get())|Да — thenApply, thenCompose, thenCombine, handle и т.д.|
|Обработка исключений в цепочке|Только в get() (блокирует)|Встроено: exceptionally, handle, whenComplete|
|Параллельное выполнение нескольких|Нужно вручную через ExecutorService|Готово: allOf(), anyOf(), thenCombine()|
|Неблокирующие continuation|Нет|Да — почти все методы async-варианты (thenApplyAsync и т.д.)|
|CompletionStage|Нет|Да — можно строить реактивные пайплайны|
Коротко: **Future** — это просто «чек на результат позже», **CompletableFuture** — мощный инструмент для построения асинхронных пайплайнов.

## 6+**Как комбинировать несколько CompletableFuture**

## 7. **Обработка исключений в асинхронной цепочке**
Самые популярные способы (в порядке частоты использования):
- `exceptionally(fn)` — только при исключении → fallback-значение
```Java
cf.exceptionally(ex -> "fallback");
```
- `handle(biFn)` — всегда вызывается (result, ex) — самый универсальный
```Java
cf.handle((res, ex) -> ex != null ? fallback : res + " ok");
```
- `whenComplete(biConsumer)` — как `handle`, но не меняет результат (только side-effect)
```Java
cf.whenComplete((res, ex) → log.error("Ошибка!", ex));
```
#### Важно:
- Если не обработать исключение в цепочке → оно «всплывёт» только при `get()` / `join()`
- `exceptionally` / `handle` позволяют продолжить цепочку даже после ошибки
- `join()` кидает `CompletionException` (unchecked), `get()` — `ExecutionException` (checked)

## 8. **Параллельные запросы** (самые частые паттерны)
```Java
// 1. Ждём все (самый популярный)
CompletableFuture.allOf(f1, f2, f3)
    .thenRun(() -> { /* все готовы */ })
    .join();

// 2. Собираем результаты (часто со Stream)
List<String> results = Stream.of(f1, f2, f3)
    .map(CompletableFuture::join)
    .toList();

// 3. Первый победивший (race)
CompletableFuture.anyOf(f1, f2, f3)
    .thenAccept(winner -> { ... });

// 4. Комбинируем два независимых результата
f1.thenCombine(f2, (a, b) -> a + b);

// 5. Зависимая последовательность (flatMap-стиль)
f1.thenCompose(res -> callNextService(res));
```
Для большого количества → часто используют allOf + массив / список + join() / Stream.

## 9. **Блокирующий vs неблокирующий код**

|Стиль|Пример вызова|Блокирует поток?|Когда использовать|Типичный пул потоков|
|---|---|---|---|---|
|Блокирующий|future.get()|Да|Тесты, main, batch-задачи|—|
|Блокирующий, но удобный|future.join()|Да|То же, но без checked exceptions|—|
|Неблокирующий continuation|thenApplyAsync(...)|Нет|Веб / реактивные приложения|ForkJoinPool.commonPool()|
|Неблокирующий с кастомным пулом|thenApplyAsync(..., executor)|Нет|Контроль нагрузки, I/O-bound задачи|Собственный ThreadPoolExecutor|
|Полностью асинхронный пайплайн|цепочка then... без get/join|Нет|Spring WebFlux, микросервисы, высокая нагрузка|—|

## Лучшая практика 2025–2026:
- В контроллерах / сервисах — **никогда** не вызывать `get()` /` join()` в основном потоке
- Возвращать `CompletableFuture<T>` клиенту (или `Mono`/`Flux` в реактивном стеке)
- Для I/O-bound → свой пул с фиксированным размером (не commonPool)

---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75
---

# Место № 19 // 32 интервью из 75


