Вот краткие, чёткие и содержательные ответы на типичные вопросы по теме **Records + Generics** для уровня Java Middle (собеседование 2024–2026):

---
## 1. **Чем record отличается от обычного класса?**
- Неизменяемый (immutable) по умолчанию
- Автоматически генерирует: `equals()`, `hashCode()`, `toString()`, геттеры
- Все поля — `private final`
- Нельзя наследоваться от другого класса (кроме `java.lang.Record`)
- Нельзя быть абстрактным
- Запрещено менять состояние после создания (нет сеттеров)
- Очень компактный синтаксис
> Коротко: record — это «value class» / «data carrier» с минимумом бойлерплейта.

## 2. **Ограничения record** <br>(наследование, поля, конструктор)    
- **Наследование** — нельзя extends другой класс (только implicit от Record)
- **Реализация интерфейсов** — можно
- **Поля** — только те, что в заголовке record (добавлять обычные поля нельзя)
- **Конструкторы** —
	- есть канонический (с параметрами всех компонент)
    - можно добавлять дополнительные конструкторы
    - можно переопределять канонический (compact constructor)
- Нельзя объявлять не-final поля
- Нельзя добавлять методы, которые меняют состояние компонент

## 3. **Wildcards: extends и super**<br>(**PECS** — Producer Extends, Consumer Super)    
```java
List<? extends Number> producer  → можно только читать (get → Number)
List<? super   Integer> consumer → можно только писать (add → Integer или ниже)
```

| Wildcard        | Где обычно используется            | Что можно делать | Что нельзя                            |
| :-------------- | :--------------------------------- | :--------------- | :------------------------------------ |
| `? extends T`   | Producer <br>(возвращает элементы) | get → T          | add (кроме null <br>в редких случаях) |
| `? super T`     | Consumer <br>(принимает элементы)  | add → T          | get → только Object                   |
| `? (unbounded)` | Не знаем тип вообще                | get → Object     | add → почти ничего                    |

## 4. **Type Erasure** — что это и как проявляется?    
- На этапе компиляции вся информация о generic-типах сохраняется
- После компиляции (в байт-коде) generic-типы стираются → остаются raw-типы
- `List<String>` → `List` в runtime
- Проблемы, которые из-за этого возникают:
   - Нельзя new T()
   - Нельзя new T[]
   - Нельзя` instanceof List<String>` (только raw или unbounded wildcard)
   - Нельзя создать массив generic-типов T[] arr = new T[10];
- Решения: Type Token, Class<T>, супертип-токены (Gson, Jackson)


## 5. **Bounded Type Parameters** — что это?

```java
<T extends Number & Comparable<T>>   // верхняя граница (upper bound)
<T super   Number>                   // нижняя граница (lower bound) — редко
```

- <T extends A & B & C> — T должен реализовывать/наследоваться от всех
- Часто используется в утилитных методах, коллекциях, компараторах
- Пример:
- 
```java
public static <T extends Comparable<? super T>> T max(T a, T b) { ... }
```

Если у тебя есть конкретный вопрос/скрин из этого раздела — кидай, разберём детально и с примерами кода.

Какой следующий пункт или конкретный вопрос хочешь разобрать?