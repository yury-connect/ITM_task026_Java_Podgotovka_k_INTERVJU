— наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.

Параллельный сборщик включается опцией ==`-XX:+UseParallelGC`==.

### Принципы работы
При подключении параллельного сборщика используются те же самые подходы к организации кучи, что и в случае с **Serial GC** — она делится на такие же регионы Eden, Survivor 0, Survivor 1 и Old Gen (знакомый нам под именем Tenured), функционирующие по тому же принципу. Но есть два принципиальных отличия в работе с этими регионами:
	во-первых, сборкой мусора занимаются несколько потоков параллельно; 
	во-вторых, данный сборщик может самостоятельно подстраиваться под требуемые параметры производительности. Давайте разберемся, как это устроено.

Для определения количества потоков, которые будут использоваться при сборке мусора, на компьютере с N ядрами процессора, JVM по умолчанию применяет следующую формулу: если N ≤ 8, то количество потоков равно N, иначе для получения количества потоков N домножается на коэффициент, зависящий от других параметров, обычно это 5/8, но на некоторых платформах коэффициент может быть меньше.

По умолчанию и **малая** и **полная сборка** задействуют многопоточность. **Малая** пользуется ею при переносе объектов в **старшее поколение**, а **полная** — при уплотнении данных в старшем поколении.

Каждый поток сборщика получает свой участок памяти в регионе Old Gen, так называемый _буфер повышения (promotion buffer)_, куда только он может переносить данные, чтобы не мешать другим потокам. Такой подход ускоряет сборку мусора, но имеет и небольшое негативное последствие в виде возможной фрагментации памяти:  
![|446x195](./_Attachments_Parallel_GC/Pasted%20image%2020241017171726.png)
  
Интеллектуальная составляющая улучшений параллельного сборщика относительно последовательного заключается в том, что у него есть настройки, ориентированные на достижение необходимой вам эффективности сборки мусора. Вы можете указать устраивающие вас параметры производительности — максимальное время сборки и/или пропускную способность — и сборщик будет изо всех сил стараться не превышать заданные пороги. Для этого он будет использовать статистику уже прошедших сборок мусора и исходя из нее планировать параметры дальнейших сборок: варьировать размеры поколений, менять пропорции регионов.

В случае, если вы задали **слишком жесткие требования**, которые сборщик не может выполнить, он будет ориентироваться на следующие приоритеты (в порядке убывания важности):  

1. Снижение максимальной паузы.
2. Повышение пропускной способности.
3. Минимизация используемой памяти.


### Ситуации STW

Как и в случае с последовательным сборщиком, на время операций по очистке памяти все основные потоки приложения останавливаются. Разница только в том, что пауза, как правило, короче за счет выполнения части работ в параллельном режиме.

### Достоинства и недостатки

**Бесспорным плюсом** данного сборщика на фоне Serial GC является возможность автоматической подстройки под требуемые параметры производительности и меньшие паузы на время cборок. При наличии нескольких процессорных ядер выигрыш в скорости будет практически во всех приложениях.  
  
Определенная фрагментация памяти, конечно, **является минусом**, но вряд ли она будет существенной для большинства приложений, так как сборщиком используется относительно небольшое количество потоков.  
  
В целом, Parallel GC — это простой, понятный и эффективный сборщик, подходящий для большинства приложений. У него нет скрытых накладных расходов, мы всегда можем поменять его настройки и ясно увидеть результат этих изменений.

---
