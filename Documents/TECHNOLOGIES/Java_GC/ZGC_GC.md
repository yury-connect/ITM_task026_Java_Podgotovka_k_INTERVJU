пытается удерживать паузы на субмиллисекундном уровне, даже при работе с очень большими кучами.

## Цветные указатели

Для достижения своих целей ZGC использует подход, называемый раскрашиванием указателей. На практике это означает, что каждый 64-битный указатель (а ZGC поддерживает только 64-битные системы) содержит не только адрес памяти, но и дополнительные метаданные, определяющие текущий статус указателя.

Под адрес в указателе выделяется от 42 до 44 младших бит в зависимости от установленного максимального размера кучи. Это значит, что ZGC может работать с кучами размером до 16 ТБ (одну из трех поставленных задач уже решили, это было несложно). До версии JDK 13 был вариант только с 42-битными адресами и ограничением на размер кучи 4 ТБ. Мы в данной статье будем рассматривать вариант с 44-битным указателем.

Еще четыре бита выделено под метаданные:

- Marked0 (0001) и Marked1 (0010) — используются для пометки указателей на разных фазах сборки.
    
- Remapped (0100) — указатель помечается этим битом в случае, если адрес в указателе является окончательным и не должен модифицироваться в рамках текущего цикла сборки.
    
- Finalizable (1000) — этим битом помечаются объекты, достижимые только из финализатора.
    

Комбинация этих флагов определяет состояние указателя, которое при описании ZGC называется его "цветом".

А что с остальными 16-ю битами? Они всегда равны нулю и не используются.

В итоге, указатель на объект в памяти JVM при использовании ZGC имеет такую структуру:
![|736x128](./_Attachments_ZGC_GC/Pasted%20image%2020241017182744.png)

Теперь давайте объединим это знание с тем, что мы вспомнили про устройство виртуальной памяти. В этом случае нулевой адрес (младшие 44 бита) с тем или иным установленным "красочным" битом будет представлять собой начало 16-терабайтной области в виртуальной памяти. Причем все эти области проецируются на одну и ту же область физической памяти — на кучу JVM:
![|737x247](./_Attachments_ZGC_GC/Pasted%20image%2020241017182810.png)

Это значит, что устанавливая или снимая какой-либо из битов метаданных указателя (перекрашивая указатель), не меняя адреса, мы переносимся в другую область виртуальной памяти, но при этом получаем виртуальный указатель на тот же самый объект, на который ссылались до перекрашивания. Удобно.

## Барьеры

Еще одной особенностью ZGC является использование т. н. _барьеров_ (_barriers_) во время конкурентных фаз сборки мусора (когда сборщик работает одновременно с приложением, не останавливая его выполнение).

Барьер — это просто функция, которая принимает указатель на объект в памяти, анализирует цвет этого указателя, в зависимости от цвета выполняет какие-либо действия с этим указателем или даже с самим объектом, на который он ссылается, после чего возвращает актуальное значение указателя, которое необходимо использовать для доступа к объекту.

Важной особенностью функции-барьера является то, что она выполняется в том числе в рамках основных потоков приложения. То есть сборкой мусора занимаются не только выделенные потоки GC, но и само приложение, чего мы в предыдущих сборщиках не встречали.

Какие конкретно манипуляции барьеры производят с указателями и с объектами, мы рассмотрим ниже. Пока что нам достаточно знаний просто про наличие таких барьеров.

## Поиск живых объектов

Теперь давайте посмотрим, как ZGC использует цветные указатели и барьеры для очистки кучи. Первым этапом работы сборщика является покраска указателей на достижимые объекты.

Для иллюстрации работы ZGC будем использовать пример из презентации Oracle. Начинается всё с такого расположения и состояния объектов:
![|737x229](./_Attachments_ZGC_GC/Pasted%20image%2020241017183154.png)

Дальше в описании мы будем раскрашивать указатели разными цветами в соответствии с состоянием их метаданных. Для наглядности объекты тоже будем раскрашивать.

Этап поиска живых объектов и первоначальной раскраски ссылок состоит из трех фаз:

**Фаза Pause Mark Start**

Сборка мусора, как обычно, начинается с поиска живых объектов. А поиск живых объектов, как обычно, начинается с поиска объектов, достижимых из корней. Для этого ZGC использует короткую STW-паузу. 

Особенностью ZGC является то, что в процессе обхода кучи он не только определяет, какие из объектов являются живыми, но и попутно красит указатели, по которым путешествует, устанавливая у них один из битов Marked0 или Marked1.

На этом этапе выберем красный цвет для раскрашивания ссылок, по которым мы добирались до живых объектов. В результате получаем такую картину:
![|738x226](./_Attachments_ZGC_GC/Pasted%20image%2020241017183228.png)

**Фаза Concurrent Map**

После того, как найдены все объекты, достижимые из корней, работа приложения возобновляется и начинается вторая фаза сборки, в которой сборщик продолжает поиск живых объектов, достижимых из найденных корней, но уже в конкурентном режиме.

Так как во время этой фазы приложение работает и может создавать новые объекты, в этот период активно используются барьеры, которые красят все указатели, по которым в это время производится доступ к объектам.

**Фаза Pause Mark End**

После завершения конкурентной фазы опять возникает пауза STW, в рамках которой ZGC обрабатывает различные специальные кейсы. В частности, soft- и weak-references.

В результате все указатели на живые объекты оказываются раскрашенными, а все объекты, до которых можно добраться по таким указателям, являются достижимыми:
![|735x231](./_Attachments_ZGC_GC/Pasted%20image%2020241017183257.png)

## Перемещение

Следующий этап в работе ZGC — это перемещение объектов для дефрагментации и высвобождения памяти. Данный этап так же разбит на несколько фаз:

**Фаза Concurrent Prepare for Relocate**

В рамках этой активности сборщик определяет блоки памяти, объекты из которых подлежат перемещению. Эти блоки попадают в так называемый _набор для перемещения_ (_relocation set_).

В такой набор заносятся блоки, в которых находится достаточно много мертвых объектов, чтобы их перемещение приносило пользу:
![|738x292](./_Attachments_ZGC_GC/Pasted%20image%2020241017183321.png)

**Фаза Pause Relocate Start**

Дальше начинается непосредственно перемещение объектов. Как и их поиск, перемещение начинается с объектов, достижимых из корней, и производится в рамках паузы STW.

Если объект достижим по указателю из корня и подлежит перемещению, он переносится в новый блок памяти, корневой указатель на него красится и сборщик запоминает соответствие старого и нового адреса перемещенного объекта в специальных _таблицах переадресации_ (_forwarding tables_). Такие таблицы ведутся отдельно для каждого блока в памяти за пределами кучи.

Корневые указатели на объекты, не подлежащие перемещению, просто перекрашиваются в тот же цвет.
![|738x257](./_Attachments_ZGC_GC/Pasted%20image%2020241017183346.png)

**Фаза Concurrent Relocate**

Эта фаза распространяет описанную выше активность переноса объектов (вместе с ведением таблицы переходов) на оставшуюся кучу.

Как следует из названия, происходит она в конкурентном режиме, одновременно с работой приложения. А это значит, что в рамках нее активно используются барьеры. Но эти барьеры выполняют уже не только раскраску указателей, но и физическое перемещение объектов если они обнаружили доступ по указателю к объекту, подлежащему перемещению, но еще не перемещенному.

Например, без работы барьеров картина после данной фазы выглядела бы вот так:
![|730x294](./_Attachments_ZGC_GC/Pasted%20image%2020241017183403.png)

Но если в течение этой фазы приложение попыталось получить объект 5 по устаревшему указателю из объекта 4, то барьер корректно перенаправит и перекрасит этот указатель:
![|740x295](./_Attachments_ZGC_GC/Pasted%20image%2020241017183425.png)

**Фаза Concurrent Remap**

После окончания предыдущей фазы все объекты оказываются перемещенными в целевые области памяти и единственное, что отделяет нас от окончательной целевой картины, это зависшие указатели на объекты в освобожденных регионах памяти (они остались красными на схеме).

Чтобы поправить все такие указатели, необходимо совершить еще один обход графа объектов, проследовав по всем указателям и перенаправив их на новые адреса в соответствии с таблицами переадресации. Но ZGC не выполняет эту фазу сразу в рамках текущего цикла сборки, а совмещает ее с фазой Concurrent Mark следующего цикла сборки. То есть фазы в разных циклах сборки накладываются друг на друга:
![|740x173](./_Attachments_ZGC_GC/Pasted%20image%2020241017183443.png)


После фазы Pause Mark Start следующего цикла сборки будут помечены объекты, достижимые из корней:
![|741x295](./_Attachments_ZGC_GC/Pasted%20image%2020241017183501.png)

И далее в рамках фазы Concurrent Mark коллектор пройдется по всем оставшимся указателям, обнаружит несоответствие их цветов (красные) текущей фазе сборки (синий) и поправит. Либо сама программа, получая объекты по таким зависшим указателям и вызывая срабатывание барьеров, будет перемещать объекты и перекрашивать указатели в актуальный цвет.

В результате после завершения этой фазы всё встанет на свои места:
![|740x208](./_Attachments_ZGC_GC/Pasted%20image%2020241017183516.png)

## Полная сборка

Описанный алгоритм позволяет выполнять большую часть работы по сборке мусора не останавливая работу основных потоков приложения. Но он, конечно же, не гарантирует, что у приложения в любой момент есть достаточно свободной памяти.

При активном выделении памяти может возникнуть ситуация, когда у JVM не осталось свободных блоков для размещения новых объектов. В этом случае работа приложения останавливается (пауза STW) и, как и при использовании других сборщиков, запускается цикл полной сборки мусора. Здесь, конечно, речь о субмиллисекундных паузах уже не идет.

## Достоинства и недостатки

На практике ZGC, действительно, позволяет добиться субмиллисекундных пауз, в том числе на очень больших кучах, что очень хорошо для приложений, чувствительных даже к коротким задержкам в обработке запросов.

Паузы, действительно, короткие

Но эти короткие паузы не даются бесплатно.

Во-первых, из-за наличия длительных конкурентных фаз сборки может страдать пропускная способность приложения. Насколько сильно — зависит от конкретного приложения.

Во-вторых, используемые для доступа к объектам барьеры совсем не бесплатные. В разных источниках фигурируют оценки замедления перехода по указателю на 4-5%, но это в оптимистичном сценарии, когда цвет указателя "хороший" и барьеру не требуется менять сам указатель или переносить соответствующий объект на новое место. В случае обнаружения "нехорошего" цвета указателя барьеру придется уйти на длинный путь и потратить значительно больше времени на приведение данных в порядок.

В-третьих, чтобы держать паузы на субмиллисекундном уровне и не допускать полных сборок мусора ZGC требуется достаточное количество свободных регионов памяти. Если ваше приложение очень активно создает новые объекты, ему, скорее всего, потребуется куча чуть большего размера, чем при использовании того же G1.

---
