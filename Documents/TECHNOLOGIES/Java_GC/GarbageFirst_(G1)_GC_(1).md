# GarbageFirst (G1) GC
**G1** (**Garbage-First**) создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.
Начиная с **Java 9**, он является сборщиком мусора **по умолчанию** в виртуальной машине **HotSpot** [](https://doc.ruscomtech.ru/index.php?title=%D0%A1%D0%B1%D0%BE%D1%80%D1%89%D0%B8%D0%BA_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0_G1_-_Java_9&oldid=100)[](https://dev.java/learn/jvm/tool/garbage-collection/java-specifics/#garbage-collection-process)[](https://www.cleverence.com/articles/oracle-documentation/garbage-first-g1-garbage-collector-java-9473/). Его главная цель — баланс между высокой пропускной способностью и низкими задержками, обеспечивая паузы <u>«stop-the-world» заданной продолжительности (по умолчанию 200 мс)</u> [](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html)[](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html)[](https://www.cleverence.com/articles/oracle-documentation/garbage-first-g1-garbage-collector-java-9473/).
G1 включается опцией Java ==`-XX:+UseG1GC`==.

### Принципы работы  
Первое, что бросается в глаза при рассмотрении G1 — это изменение подхода к организации кучи. Здесь память разбивается на множество регионов одинакового размера. Размер этих регионов зависит от общего размера кучи и по умолчанию выбирается так, чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. Исключение составляют только так называемые _громадные (humongous) регионы_, которые создаются объединением обычных регионов для размещения очень больших объектов.  
  
Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению. Пример разделения кучи на регионы может выглядеть следующим образом (количество регионов сильно приуменьшено):
![|457x88](_Attachments_GarbageFirst_(G1)_GC_(1)/Pasted%20image%2020241017172948.png)

Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

Следует иметь в виду, что для получения списка живых объектов G1 использует алгоритм Snapshot-At-The-Beginning (SATB), то есть в список живых попадают все объекты, которые были таковыми на момент начала работы алгоритма, плюс все объекты, созданные за время его выполнения. Это, в частности, означает, что G1 допускает наличие плавающего мусора, с которым мы познакомились при рассмотрении сборщика CMS.  
  
После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.  
  
Очередной цикл пометки и, как следствие, очередные смешанные сборки будут запущены тогда, когда заполненность кучи превысит определенный порог.  
  
Смешанная сборка мусора в приведенном выше примере кучи может пройти вот так:
![|460x198](_Attachments_GarbageFirst_(G1)_GC_(1)/Pasted%20image%2020241017173158.png)

Может оказаться так, что в процессе очистки памяти в куче не остается свободных регионов, в которые можно было бы копировать выжившие объекты. Это приводит к возникновению ситуации _allocation (evacuation) failure_, подобие которой мы видели в CMS. В таком случае сборщик выполняет полную сборку мусора по всей куче при остановленных основных потоках приложения.  
  
Опираясь на уже упомянутую статистику о предыдущих сборках, G1 может менять количество регионов, закрепленных за определенным поколением, для оптимизации будущих сборок.

### Гиганты
В начале рассказа о G1 я упомянул о существовании громадных регионов, в которых хранятся так называемые _громадные объекты (humongous objects)_. С точки зрения JVM любой объект размером больше половины региона считается громадным и обрабатывается специальным образом:  

- Он никогда не перемещается между регионами.
- Он может удаляться в рамках цикла пометки или полной сборки мусора.
- В регион, занятый громадным объектом, больше никого не подселяют, даже если в нем остается свободное место.

### Ситуации STW  
Если резюмировать, то у G1 мы получаем STW в следующих случаях:  

1. Процессы переноса объектов между поколениями. Для минимизации таких пауз G1 использует несколько потоков.
2. Короткая фаза начальной пометки корней в рамках цикла пометки.
3. Более длинная пауза в конце фазы remark и в начале фазы cleanup цикла пометки.

### Достоинства и недостатки  
В целом считается, что сборщик G1 более аккуратно предсказывает размеры пауз, чем CMS, и лучше распределяет сборки во времени, чтобы не допустить длительных остановок приложения, особенно при больших размерах кучи. При этом он лишен и некоторых других недостатков CMS, например, он не фрагментирует память.  
  
Расплатой за достоинства G1 являются ресурсы процессора, которые он использует для выполнения достаточно большой части своей работы параллельно с основной программой. В результате страдает пропускная способность приложения. Целевым значением пропускной способности по умолчанию для G1 является 90%. Для Parallel GC, например, это значение равно 99%. Это, конечно, не значит, что пропускная способность с G1 всегда будет почти на 10% меньше, но данную особенность следует всегда иметь в виду.
