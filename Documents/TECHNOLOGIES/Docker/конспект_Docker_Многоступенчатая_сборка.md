# Краткий [конспект](https://suchkov.tech/%d0%bc%d0%bd%d0%be%d0%b3%d0%be%d1%81%d1%82%d1%83%d0%bf%d0%b5%d0%bd%d1%87%d0%b0%d1%82%d0%b0%d1%8f-%d1%81%d0%b1%d0%be%d1%80%d0%ba%d0%b0-docker/) от [suchkov tech](https://www.youtube.com/@suchkov-tech) // [blog](https://suchkov.tech/blog/):
Многоступенчатая сборка Docker

![](https://suchkov.tech/wp-content/uploads/2024/03/Docker-preivew-8-1-1024x306.png)

Компилировать и собирать приложение из исходного кода лучше непосредственно в процессе сборки образа – так мы минимизируем влияние своей собственной операционной системы, однако у этого есть и обратная сторона. Размеры образов построенных таким образом порой получаются достаточно большими.

Причина этого в следующем. Из-за того что мы собираем свое приложение на этапе построения образа, мы также тащим за собой все инструменты и библиотеки, которые были необходимы только для сборки и компиляции, но не для работы самого приложения. Так, для запуска приложения на java нам достаточно иметь JRE в контейнере где будет запущено приложение, а тащить за собой весь JDK и зависимости – излишество. Аналогично и для приложения на go – инструменты языка go нам нужны только на этапе компиляции приложения, сам бинарный файл же не требует ничего дополнительно для работы.

Решить эту проблему можно с помощью **многоступенчатой сборки**.

Dockerfile в этом случае состоит из нескольких **ступеней** или **стадий**, каждая из которых по структуре выглядит как Dockerfile состоящий из одной ступени. У разных ступеней Dockerfile могут быть разные базовые образы, и каждая последующая ступень может пользоваться результатами предыдущих ступеней для построения своего образа.

![](https://suchkov.tech/wp-content/uploads/2024/03/Docker-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B5%D0%BD%D1%87%D0%B0%D1%82%D0%B0%D1%8F-%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D0%B8-%D0%B0%D0%BB%D1%8C%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%82%D0%B8%D0%B2%D1%8B-Dockerfile-1024x576.png)

Пример Dockerfile состоящего из одной ступени для приложения на go

```plain
FROM golang:1.21-alpine
WORKDIR /app
COPY main.go .
RUN go build -o hello-go main.go
CMD ["./hello-go"]
```

А ниже пример многоступенчатой сборки того же приложения

```plain
# первая ступень
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY main.go .
RUN go build -o hello-go main.go

# вторая ступень
FROM alpine:3.15
WORKDIR /app
COPY --from=builder /app/hello-go .
CMD ["./hello-go"]
```

Здесь для построения приложения использовался базовый образ `golang:1.21-alpine`, а для запуска – `alpine:3.15` . В результате итоговый образ получается сильно меньшего размера.

### Примеры проектов на Java и Go

- [Java](https://github.com/SuchkovDenis/java-hello-multistage)
- [Go](https://github.com/SuchkovDenis/go-hello-multistage)

Подробнее в [видео на Youtube](https://youtu.be/9NqfyBcCyUs)

