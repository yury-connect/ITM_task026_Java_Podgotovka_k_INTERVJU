# Коротко — суть (*1-2 предложения*)

В Spring зависимости можно внедрять тремя основными способами: **конструкторное**, **сеттерное (метод)** и **поле**. Лучший выбор — **constructor injection** (чёткие зависимости, immutable, тестируемость); field-injection — удобен, но **не рекомендуется** для продакшна и тестируемости.

---
# 1. Constructor injection (*внедрение через конструктор*) ✅

```java
@Component
public class OrderService {
  private final PaymentClient paymentClient;
  public OrderService(PaymentClient paymentClient) {
    this.paymentClient = paymentClient;
  }
}
```

**Плюсы**
- Зависимости видны в сигнатуре — явность и неизменяемость (`final` поля).    
- Легко тестировать (вручную передаёшь моки).    
- Нет проблем с частично инициалированными бинами (bean полностью сконструирован).  

**Минусы**    
- Циклические зависимости _не разрешаются_ автоматически (для singletons можно обойти `@Lazy`/`ObjectFactory`/`Provider`).  
    **Когда использовать:** по умолчанию для всех сервисов/репозиториев.

---
# 2. Setter / Method injection (*внедрение через сеттер/метод*) ⚖️

```java
@Component
public class ReportService {
  private ReportFormatter formatter;

  @Autowired
  public void setFormatter(ReportFormatter formatter) {
    this.formatter = formatter;
  }
}
```

**Плюсы**
- Подходит для _опциональных_ зависимостей и для переустановки/конфигурации после создания.    
- Позволяет избежать некоторых циклов (инъекция после конструктора).  

**Минусы**
- Поле не может быть `final`, менее явные зависимости.  
    **Когда использовать:** если зависимость действительно optional или должна быть заменяема в рантайме.

---
# 3. Field injection (*инъекция в поле*) ⚠️

```java
@Component
public class PaymentController {
  @Autowired
  private PaymentClient paymentClient;
}
```

**Плюсы**
- Очень кратко и удобно (меньше шаблона кода).  

**Минусы**    
- Скрытые зависимости → хуже тестируемость (нужны reflection/сложные Mockito-хаки или SpringRunner).    
- Нельзя задать `final`.    
- Нередко считается «анти-паттерном» в серьёзных проектах.  
    **Когда:** быстрые PoC, тестовые коды; не для production-core.

---
# Под капотом (*как Spring это делает и влияние на быстродействие*) — Java Reflection

1. **Резолв и создание бина**    
    - `BeanDefinition` → `ConstructorResolver` (если конструктора несколько) → `InstantiationStrategy` создаёт объект (обычно через `Constructor.newInstance()` или CGLIB/ReflectionFactory для специальных случаев).        
    - Для сеттеров/полей Spring использует `ReflectionUtils.makeAccessible(...)` и затем `Method.invoke()` / `Field.set()` для установки значения.
    
2. **Кэширование**    
    - Spring кэширует метаданные (выбранный конструктор, `DependencyDescriptor`, рефлекшн-объекты), поэтому **рефлекшн-стоимость платится один раз — в startup**.
    
3. **Влияние на производительность**    
    - **Startup**: рефлекшн-операции (инспекция классов, выбор конструкторов, вызовы `setAccessible`) дают основную стоимость при старте.        
    - **Runtime**: после инициализации прямые вызовы методов/полей уже обычные — особой разницы **нет**. Constructor injection даже чуть эффективнее в рантайме, потому что зависимости уже в final полях — никаких доп. reflective calls.        
    - Метод/field-injection использует `Method.invoke`/`Field.set` **только при создании бина**, не при каждом вызове метода сервиса.
    
4. **Оптимизации JVM / Spring**    
    - Spring снижает overhead кэшированием и редко использует медленные пути; JIT-компилятор оптимизирует вызовы, поэтому влияние на throughput — **практически нулевое** для типичных сервисов.
    
5. **Особые случаи**    
    - `@Lookup` / method injection использует bytecode/CGLIB для динамической подстановки — чуть сложнее, но всё равно cached и выполняется в стартап/при getBean.

---
# Циклические зависимости — поведение

- **Setter/field injection**: Spring умеет решать циклы для **singleton** через ранние кэши (`earlySingletonObjects`), поэтому circular deps возможны.
    
- **Constructor injection**: по-умолчанию **не** решается (нужно `@Lazy` или `ObjectProvider`/`Provider`/`@Autowired` с `required=false` или Pattern с фабриками).

---
# Рекомендации / что сказать на собеседовании (коротко)

- **Constructor injection — основной, используйте его**: явность, `final`, тестируемость, иммутабельность.
    
- **Setter** — для опциональных/заменяемых зависимостей.
    
- **Field** — удобно, но **не рекомендуем** (тесты, скрытые зависимости).
    
- По производительности: **разница минимальна**, рефлекшн-затраты происходят при старте и кэшируются; runtime-overhead практически отсутствует.

---
