# Какие три типа стратегий наследования мапинга в JPA?
#### Какие три типа стратегий наследования мапинга (_Inheritance Mapping Strategies_) описаны в `JPA`?

---
## 🧬 Стратегии наследования _маппинга_ в _JPA_ (`Inheritance Mapping Strategies`)
Стратегии наследования позволяют *JPA*-провайдеру (_например, `Hibernate`_) определить, как представлять классы-наследники в БД.

## 📑 1. `SINGLE_TABLE` — **Одна** таблица на всю иерархию // Стратегия одной таблицы _([Single Table](https://www.profit247.ru/posts/398))_
###### ====*Parent(P)* & *Child(C)* в **одной** таблице, незадействованные поля P&C = `null`. <br>т.е. если *1_000* сущностей - то все *в одной* таблице====
Все сущности сохраняются в **одну общую таблицу**.  
Для различения типов используется специальная колонка — `@DiscriminatorColumn`.

| **Плюсы**                    | **Минусы**                                                     |
| ---------------------------- | -------------------------------------------------------------- |
| ✅ Высокая производительность | ❌ Много `NULL`-полей (_поля всех наследников в одной таблице_) |
| ✅ Простая реализация         | ❌ Нельзя применять `NOT NULL` к специфичным полям              |
| ✅ Поддержка полиморфизма     | ❌ Ограничения гибкости схемы                                   |
#### 🛠️ Аннотации:
```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "EMP_TYPE")
@DiscriminatorValue("P")
```

---
### 🔗 2. `JOINED` — Таблицы **связываются через `JOIN`** // Стратегия присоединенной таблицы _([Joined Table](https://www.profit247.ru/posts/398))_
###### ====*Parent(P)* в **1-й** таблице & *Child(C)* в **2-й**, связь P&C через `Join`.<br>т.е. если *1_000* сущностей - то будет всего *2* таблицы====
Каждый класс имеет **свою таблицу**.  
Таблица **родителя** хранит **общие** поля, а таблицы **наследников** — только **специфичные**.  
Все таблицы связаны `JOIN`'ами.

|**Плюсы**|**Минусы**|
|---|---|
|✅ Нормализованная структура|❌ Потери производительности при `JOIN`-ах|
|✅ Нет лишних `NULL`-полей|❌ Усложнение запросов|
|✅ Поддержка ограничений|❌ Идентификатор (`@Id`) только в родительской таблице|
#### 🛠️ Аннотация:
```java
@Inheritance(strategy = InheritanceType.JOINED)
```

---
### 🧾 3. `TABLE_PER_CLASS` — Отдельная таблица для каждого класса // Стратегия таблицы для каждого класса _([Table Per Class](https://www.profit247.ru/posts/398))_
###### ====*Parent(P)* & *Child(C)* каждой сущности окажутся в **отдельной** таблице.<br>т.е. если *1_000* сущностей - то будет *1_000* таблиц====
Каждый наследник сохраняется в **свою таблицу**, включая **все унаследованные поля**.

|**Плюсы**|**Минусы**|
|---|---|
|✅ Нет `NULL`-полей|❌ Нет поддержки полиморфных запросов (`UNION` _нужен вручную_)|
|✅ Простая реализация подклассов|❌ Производительность зависит от количества таблиц|
#### 🛠️ Аннотация:
```java
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
```

---
### 🧠 Неявный полиморфизм (`Implicit Polymorphism`)
Дополнительная особенность: `Hibernate` — сущности участвуют в полиморфных запросах только если явно указаны.  
Это может быть полезно для ограничения выборки или оптимизации.
> 💡 Для всех стратегий используется аннотация `@Inheritance`.

| Стратегия            | Суть                                                                                                                                                                                                                                                 | Плюсы                                | Минусы                                       |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ | -------------------------------------------- |
| 🟨 `SINGLE_TABLE`    | Все сущности в одной таблице, тип различается через `@DiscriminatorColumn`                                                                                                                                                                           | ✅ Быстро  <br>✅ Просто               | ❌ Много `NULL`  <br>❌ Ограничения `NOT NULL` |
| 🟦 `JOINED`          | **Своя** таблица для **каждого** класса, `JOIN` связываются по `ID`  <br>Родительская таблица — общие поля                                                                                                                                           | ✅ Нормализация  <br>✅ Ограничения    | ❌ JOIN-ы медленные  <br>❌ Сложные запросы    |
| 🟥 `TABLE_PER_CLASS` | Каждая сущность — отдельная таблица со всеми полями суперкласса  <br>Стратегия "Каждый сам за себя" 💪  <br>* Каждая таблица — **полная копия полей суперкласса + своих**  <br>* **Никакой связи** между таблицами — _как будто они не родственники_ | ✅ Нет `NULL`  <br>✅ Простота классов | ❌ Нет полиморфизма  <br>❌ `UNION`-запросы    |

### 🔧 Аннотации:
```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // или JOINED, TABLE_PER_CLASS
@DiscriminatorColumn(name = "EMP_TYPE")
@DiscriminatorValue("P")
```

📌 **Hibernate** также поддерживает `implicit polymorphism` — не все сущности участвуют в полиморфных запросах по умолчанию.

---

## 📌 Выбор стратегии:
### 🟨 `SINGLE_TABLE` _(простота и скорость)_ — выбирай если:
> - важна производительность
> - структура данных не сложная
> - полиморфные запросы — частое явление
> - нормально относишься к NULL-полям

### 🟦 `JOINED` _(нормализация и порядок)_ — бери, если:
> - любишь нормализованные БД
> - хочешь чистую архитектуру
> - не страшны JOIN-запросы

### 🟥 `TABLE_PER_CLASS` _(независимость и автономность)_— подойдёт:
> - если работаешь с абсолютно независимыми сущностями
> - хочешь простые таблицы
> - тебе не нужен полиморфизм
## 🧬 Сравнение стратегий наследования в _JPA_:

|Аспект|🟨 `SINGLE_TABLE`|🟦 `JOINED`|🟥 `TABLE_PER_CLASS`|
|---|---|---|---|
|📦 Структура БД|Одна таблица для всей иерархии|N (_по числу сущностей_)|N (_по числу сущностей_)|
|🏷️ Идентификация типа|`@DiscriminatorColumn` + `@DiscriminatorValue`|⚠ `@DiscriminatorColumn` (опционально)|❌ Не используется|
|⛓️ `JOIN`-ы при запросе|❌ Нет|✅ Обязательно|❌ Нет (но нужен UNION для всех)|
|📉 Производительность|🔥 Лучшая (_нет `JOIN`, одна таблица_)|🐢 Хуже, из-за `JOIN`-ов|🐌 Низкая, зависит от кол-ва классов и сложности `UNION`|
|🤹‍♀️ Поддержка полиморфизма|✅ Полная|✅ Полная|⚠ Ограниченная|
|🧹 `NULL`-поля|❌ Много|✅ Мало|✅ Нет|
|🧱 Нормализация данных|❌ Низкая, возможны `NULL` в колонках|✅ Высокая, без дублирования|❌ Низкая, данные дублируются|
|📐 Структура БД|Простая, но грубая наследуемых полей|`@Id` только в суперклассе|Нет общего `@Id`, дублирование полей|
|🧰 Типовое применение|✅ Скорость, простота (_используется по умолчанию_)|Строгая архитектура, нормализация|Независимые таблицы|

---
>🧠 _Немного юмора:
> 
> 🟨 `SINGLE_TABLE` 👉 Вся семья живёт **в одной комнате**, 
> 	у каждого — **своя полочка**, но у многих полочки **пустые**... 🛏️🧳  
> 🟦 `JOINED` — это когда семья живёт **в одном доме**, 
> 	но **у каждого своя комната**. 👨‍👩‍👧‍👦  
> 🟥 `TABLE_PER_CLASS` — это когда все **разъехались**, 
> 	но **мебель** у всех **одинаковая**. 😆
---

```
***** из методички *****
Inheritance Mapping Strategies Стратегии наследования нужны для того, 
чтобы дать понять провайдеру (Hibernate) как ему отображать в БД сущности-наследники:

1) Одна таблица на всю иерархию классов (SINGLE_TABLE) — все enity, со всеми наследниками 
записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. 
Например, если есть entity Animals c классами-потомками Cats и Dogs, 
при такой стратегии все entity записываются в таблицу Animals, но при это имеют 
дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». 
Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, 
которые будет пусты для всех других классов-потомков. 
Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес 
приносить тапки от dogs, которые будут всегда иметь null для dog и cat соотвественно.
Минусом стратегии является невозможность применения ограничения NOT NULL для тех колонок таблицы, 
которые характерны только для классов-наследников, но можно использовать тригеры. 
Является стратегией по умолчанию. @DiscriminatorColumn(name = "EMP_TYPE") - имя общей колонки 
указывающий на принадлежность к классу @DiscriminatorValue("P") - 
указывает какое имя будет отображенно в @DiscriminatorColumn

2) Стратегия «соединения» (JOINED) — В данной стратегии корневой класс иерархии представлен отдельной таблицей, 
а каждый класс-наследник имеет свою таблицу, в которой отображены только поля этого класса-наследника, 
дополнительно устанавливается связь (relationships) между этими таблицами, например в случае 
классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана 
только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals 
все остальные данные cats и dogs c ссылкой на соответствующие таблицы. 
Минусом тут являются потери производительности от объединения таблиц (join) для любых операций. 
@Id, который должен быть определен только в родительской таблице.

3) Таблица для каждого класса (TABLE_PER_CLASS) — каждый отдельный класс-наследник имеет свою таблицу, 
Во всех таблицах подклассов хранятся все поля этого класса плюс те, которые унаследованы от суперкласса. 
т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы 
cats и dogs как если бы они вообще не имели общего суперкласса. 
Минусом является плохая поддержка полиморфизма (polymorphic relationships) 
и то что для выборки всех классов иерархии потребуются большое количество 
отдельных sql запросов или использование UNION запроса.

Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки)                                                                                                                                                                                                                                                                                                                                          
Кроме того, Hibernate поддерживает четвёртый, немного другой вид полиморфизма:

Неявный полиморфизм (implicit polymorphism)
```
